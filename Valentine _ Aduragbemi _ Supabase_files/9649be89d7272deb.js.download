;!function(){try { var e="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof global?global:"undefined"!=typeof window?window:"undefined"!=typeof self?self:{},n=(new e.Error).stack;n&&((e._debugIds|| (e._debugIds={}))[n]="e698002f-534e-6ddd-7d1b-646261a0053a")}catch(e){}}();
(globalThis.TURBOPACK||(globalThis.TURBOPACK=[])).push(["object"==typeof document?document.currentScript:void 0,967533,332357,29659,193767,212695,977540,e=>{"use strict";var t=e.i(479084);function n(e,t){let n=`select count(*) from ${c(e)}`,{filters:i}=t??{};return i&&(n=s(n,i)),n+";"}function i(e,t){let n=`truncate ${c(e)}`,{cascade:i}=t??{};return i&&(n+=" cascade"),n+";"}function a(e,n,i){if(!n||0===n.length)throw Error("no filters for this delete query");let a=`delete from ${c(e)}`,{returning:r,enumArrayColumns:o}=i??{};return n&&(a=s(a,n)),r&&(a+=void 0===o||0===o.length?" returning *":` returning *, ${o.map(e=>`${(0,t.ident)(e)}::text[]`).join(",")}`),a+";"}function r(e,n,i){if(!n||0===n.length)throw Error("no value to insert");let{returning:a,enumArrayColumns:r}=i??{},o=Object.keys(n[0]).map(e=>(0,t.ident)(e)).join(","),l="";return l=0==o.length?(0,t.format)("insert into %1$s select from jsonb_populate_recordset(null::%1$s, %2$s)",c(e),(0,t.literal)(JSON.stringify(n))):(0,t.format)("insert into %1$s (%2$s) select %2$s from jsonb_populate_recordset(null::%1$s, %3$s)",c(e),o,(0,t.literal)(JSON.stringify(n))),a&&(l+=void 0===r||0===r.length?" returning *":` returning *, ${r.map(e=>`${(0,t.ident)(e)}::text[]`).join(",")}`),l+";"}function o(e,n,i,a=!0,r=!1){var l,d;let u,m="";m+=`select ${n??"*"} from ${r?(l=e,`${(0,t.ident)(l.name)}`):c(e)}`;let{filters:p,pagination:_,sorts:g}=i??{};if(p&&(m=s(m,p)),g&&(d=m,m=0===(u=g.filter(e=>e.column)).length?d:d+=` order by ${u.map(e=>{let n=e.ascending?"asc":"desc",i=e.nullsFirst?"nulls first":"nulls last";return`${(0,t.ident)(e.table)}.${(0,t.ident)(e.column)} ${n} ${i}`}).join(", ")}`),_){let{limit:e,offset:n}=_??{};m+=` limit ${(0,t.literal)(e)} offset ${(0,t.literal)(n)}`}return`${m}${a?";":""}`}function l(e,n,i){let{filters:a,returning:r,enumArrayColumns:o}=i??{};if(!a||0===a.length)throw Error("no filters for this update query");let l=Object.keys(n).map(e=>(0,t.ident)(e)).join(","),d=(0,t.format)("update %1$s set (%2$s) = (select %2$s from json_populate_record(null::%1$s, %3$s))",c(e),l,(0,t.literal)(JSON.stringify(n)));return a&&(d=s(d,a)),r&&(d+=void 0===o||0===o.length?" returning *":` returning *, ${o.map(e=>`${(0,t.ident)(e)}::text[]`).join(",")}`),d+";"}function s(e,n){return 0===n.length?e:e+=` where ${n.map(e=>{if(Array.isArray(e.column))switch(e.operator){case"in":var n,i,a=e;if(!Array.isArray(a.column))throw Error("Use inFilterSql for single columns");if(!Array.isArray(a.value))throw Error("Values for a tuple 'in' filter must be an array");let r=`(${a.column.map(e=>(0,t.ident)(e)).join(", ")})`,o=a.value.map(e=>{if(Array.isArray(e)){if(e.length!==a.column.length)throw Error("Tuple value length must match column length");return`(${e.map(e=>d(e)).join(", ")})`}{let t=String(e).split(",");if(t.length!==a.column.length)throw Error("Tuple value length must match column length");return`(${t.map(e=>d(e)).join(", ")})`}});return`${r} ${a.operator} (${o.join(", ")})`;case"=":case"<>":case">":case"<":case">=":case"<=":var l=e;if(!Array.isArray(l.column))throw Error("Use standard applyFilters for single column");if(!Array.isArray(l.value))throw Error("Tuple filter value must be an array");if(l.value.length!==l.column.length)throw Error("Tuple filter value must have the same length as the column array");let s=`(${l.column.map(e=>(0,t.ident)(e)).join(", ")})`,c=`(${l.value.map(e=>d(e)).join(", ")})`;return`${s} ${l.operator} ${c}`;default:throw Error(`Cannot use ${e.operator} operator in a tuple filter`)}switch(e.operator){case"in":let u;return u=Array.isArray((n=e).value)?n.value.map(e=>d(e)):String(n.value).split(",").map(e=>d(e)),`${(0,t.ident)(n.column)} ${n.operator} (${u.join(",")})`;case"is":var m=e;let p=String(m.value);switch(p){case"null":case"false":case"true":case"not null":return`${(0,t.ident)(m.column)} ${m.operator} ${p}`;default:return`${(0,t.ident)(m.column)} ${m.operator} ${d(m.value)}`}case"~~":case"~~*":case"!~~":case"!~~*":return i=e,`${(0,t.ident)(i.column)}::text ${i.operator} ${d(i.value)}`;default:return`${(0,t.ident)(e.column)} ${e.operator} ${d(e.value)}`}}).join(" and ")}`}function d(e){if("string"==typeof e&&!(e?.startsWith("ARRAY[")&&e?.endsWith("]")))return(0,t.literal)(e);return e}function c(e){return`${(0,t.ident)(e.schema)}.${(0,t.ident)(e.name)}`}e.s(["countQuery",()=>n,"deleteQuery",()=>a,"insertQuery",()=>r,"selectQuery",()=>o,"truncateQuery",()=>i,"updateQuery",()=>l],332357);class u{table;action;options;pagination;constructor(e,t,n){this.table=e,this.action=t,this.options=n}range(e,t){return this.pagination={offset:e,limit:t-e+1},this}toSql(e={isCTE:!1,isFinal:!0}){try{let{actionValue:t,actionOptions:s,filters:d,sorts:c}=this.options??{};switch(this.action){case"count":return n(this.table,{filters:d});case"delete":return a(this.table,d,{returning:s?.returning,enumArrayColumns:s?.enumArrayColumns});case"insert":return r(this.table,t,{returning:s?.returning,enumArrayColumns:s?.enumArrayColumns});case"select":return o(this.table,t,{filters:d,pagination:this.pagination,sorts:c},e.isFinal,e.isCTE);case"update":return l(this.table,t,{filters:d,returning:s?.returning,enumArrayColumns:s?.enumArrayColumns});case"truncate":return i(this.table,{cascade:s?.cascade});default:return""}}catch(e){throw e}}}e.s(["QueryModifier",()=>u],29659);class m{table;action;actionValue;actionOptions;filters;sorts;constructor(e,t,n,i){this.table=e,this.action=t,this.actionValue=n,this.actionOptions=i,this.filters=[],this.sorts=[]}filter(e,t,n){return this.filters.push({column:e,operator:t,value:n}),this}match(e){return Object.entries(e).map(([e,t])=>{this.filters.push({column:e,operator:"=",value:t})}),this}order(e,t,n=!0,i=!1){return this.sorts.push({table:e,column:t,ascending:n,nullsFirst:i}),this}range(e,t){return this._getQueryModifier().range(e,t)}clone(){let e=structuredClone({table:this.table,action:this.action,actionValue:this.actionValue,actionOptions:this.actionOptions,filters:this.filters,sorts:this.sorts}),t=new m(e.table,e.action,e.actionValue,e.actionOptions);return t.filters=e.filters,t.sorts=e.sorts,t}toSql(e){return this._getQueryModifier().toSql(e)}_getQueryModifier(){return new u(this.table,this.action,{actionValue:this.actionValue,actionOptions:this.actionOptions,filters:this.filters,sorts:this.sorts})}}e.s(["QueryFilter",()=>m],193767);class p{table;constructor(e){this.table=e}count(){return new m(this.table,"count")}delete(e){return new m(this.table,"delete",void 0,e)}insert(e,t){return new m(this.table,"insert",e,t)}select(e){return new m(this.table,"select",e)}update(e,t){return new m(this.table,"update",e,t)}truncate(e){return new m(this.table,"truncate",void 0,e)}}e.s(["QueryAction",()=>p],212695);class _{from(e,t){return new p({name:e,schema:t??"public"})}}e.s(["Query",()=>_],977540),e.s([],967533)},907019,e=>{"use strict";e.s([],945846),e.i(945846);var t=e.i(369679),n=e.i(532729);e.s(["defaultErrorMap",()=>n.default,"getErrorMap",()=>t.getErrorMap,"setErrorMap",()=>t.setErrorMap],471238),e.i(471238);var i=e.i(24248);e.s([],366311),e.i(366311);var a=e.i(416673),r=e.i(531837),o=e.i(249909);e.s(["BRAND",()=>r.BRAND,"DIRTY",()=>i.DIRTY,"EMPTY_PATH",()=>i.EMPTY_PATH,"INVALID",()=>i.INVALID,"NEVER",()=>r.NEVER,"OK",()=>i.OK,"ParseStatus",()=>i.ParseStatus,"Schema",()=>r.Schema,"ZodAny",()=>r.ZodAny,"ZodArray",()=>r.ZodArray,"ZodBigInt",()=>r.ZodBigInt,"ZodBoolean",()=>r.ZodBoolean,"ZodBranded",()=>r.ZodBranded,"ZodCatch",()=>r.ZodCatch,"ZodDate",()=>r.ZodDate,"ZodDefault",()=>r.ZodDefault,"ZodDiscriminatedUnion",()=>r.ZodDiscriminatedUnion,"ZodEffects",()=>r.ZodEffects,"ZodEnum",()=>r.ZodEnum,"ZodError",()=>o.ZodError,"ZodFirstPartyTypeKind",()=>r.ZodFirstPartyTypeKind,"ZodFunction",()=>r.ZodFunction,"ZodIntersection",()=>r.ZodIntersection,"ZodIssueCode",()=>o.ZodIssueCode,"ZodLazy",()=>r.ZodLazy,"ZodLiteral",()=>r.ZodLiteral,"ZodMap",()=>r.ZodMap,"ZodNaN",()=>r.ZodNaN,"ZodNativeEnum",()=>r.ZodNativeEnum,"ZodNever",()=>r.ZodNever,"ZodNull",()=>r.ZodNull,"ZodNullable",()=>r.ZodNullable,"ZodNumber",()=>r.ZodNumber,"ZodObject",()=>r.ZodObject,"ZodOptional",()=>r.ZodOptional,"ZodParsedType",()=>a.ZodParsedType,"ZodPipeline",()=>r.ZodPipeline,"ZodPromise",()=>r.ZodPromise,"ZodReadonly",()=>r.ZodReadonly,"ZodRecord",()=>r.ZodRecord,"ZodSchema",()=>r.ZodSchema,"ZodSet",()=>r.ZodSet,"ZodString",()=>r.ZodString,"ZodSymbol",()=>r.ZodSymbol,"ZodTransformer",()=>r.ZodTransformer,"ZodTuple",()=>r.ZodTuple,"ZodType",()=>r.ZodType,"ZodUndefined",()=>r.ZodUndefined,"ZodUnion",()=>r.ZodUnion,"ZodUnknown",()=>r.ZodUnknown,"ZodVoid",()=>r.ZodVoid,"addIssueToContext",()=>i.addIssueToContext,"any",()=>r.any,"array",()=>r.array,"bigint",()=>r.bigint,"boolean",()=>r.boolean,"coerce",()=>r.coerce,"custom",()=>r.custom,"date",()=>r.date,"datetimeRegex",()=>r.datetimeRegex,"defaultErrorMap",()=>n.default,"discriminatedUnion",()=>r.discriminatedUnion,"effect",()=>r.effect,"enum",()=>r.enum,"function",()=>r.function,"getErrorMap",()=>t.getErrorMap,"getParsedType",()=>a.getParsedType,"instanceof",()=>r.instanceof,"intersection",()=>r.intersection,"isAborted",()=>i.isAborted,"isAsync",()=>i.isAsync,"isDirty",()=>i.isDirty,"isValid",()=>i.isValid,"late",()=>r.late,"lazy",()=>r.lazy,"literal",()=>r.literal,"makeIssue",()=>i.makeIssue,"map",()=>r.map,"nan",()=>r.nan,"nativeEnum",()=>r.nativeEnum,"never",()=>r.never,"null",()=>r.null,"nullable",()=>r.nullable,"number",()=>r.number,"object",()=>r.object,"objectUtil",()=>a.objectUtil,"oboolean",()=>r.oboolean,"onumber",()=>r.onumber,"optional",()=>r.optional,"ostring",()=>r.ostring,"pipeline",()=>r.pipeline,"preprocess",()=>r.preprocess,"promise",()=>r.promise,"quotelessJson",()=>o.quotelessJson,"record",()=>r.record,"set",()=>r.set,"setErrorMap",()=>t.setErrorMap,"strictObject",()=>r.strictObject,"string",()=>r.string,"symbol",()=>r.symbol,"transformer",()=>r.transformer,"tuple",()=>r.tuple,"undefined",()=>r.undefined,"union",()=>r.union,"unknown",()=>r.unknown,"util",()=>a.util,"void",()=>r.void],907019)},97429,e=>{"use strict";var t=e.i(907019);e.s(["z",0,t])},479084,e=>{"use strict";let t=new Set(["AES128","AES256","ALL","ALLOWOVERWRITE","ANALYSE","ANALYZE","AND","ANY","ARRAY","AS","ASC","ASYMMETRIC","AUTHORIZATION","BACKUP","BETWEEN","BIGINT","BINARY","BIT","BLANKSASNULL","BOOLEAN","BOTH","BYTEDICT","CASE","CAST","CHAR","CHARACTER","CHECK","COALESCE","COLLATE","COLLATION","COLUMN","CONCURRENTLY","CONSTRAINT","CREATE","CREDENTIALS","CROSS","CURRENT_CATALOG","CURRENT_DATE","CURRENT_ROLE","CURRENT_SCHEMA","CURRENT_TIME","CURRENT_TIMESTAMP","CURRENT_USER_ID","CURRENT_USER","DEC","DECIMAL","DEFAULT","DEFERRABLE","DEFLATE","DEFRAG","DELETE","DELTA","DELTA32K","DESC","DISABLE","DISTINCT","DO","ELSE","EMPTYASNULL","ENABLE","ENCODE","ENCRYPT","ENCRYPTION","END","EXCEPT","EXISTS","EXPLICIT","EXTRACT","FALSE","FETCH","FLOAT","FOR","FOREIGN","FREEZE","FROM","FULL","GLOBALDICT256","GLOBALDICT64K","GRANT","GREATEST","GROUP","GROUPING","GZIP","HAVING","IDENTITY","IGNORE","ILIKE","IN","INITIALLY","INNER","INOUT","INSERT","INT","INTEGER","INTERSECT","INTERVAL","INTO","IS","ISNULL","JOIN","JSON_ARRAY","JSON_ARRAYAGG","JSON_EXISTS","JSON_OBJECT","JSON_OBJECTAGG","JSON_QUERY","JSON_SCALAR","JSON_SERIALIZE","JSON_TABLE","JSON_VALUE","JSON","LATERAL","LEADING","LEAST","LEFT","LIKE","LIMIT","LOCALTIME","LOCALTIMESTAMP","LUN","LUNS","LZO","LZOP","MERGE_ACTION","MINUS","MOSTLY13","MOSTLY32","MOSTLY8","NATIONAL","NATURAL","NCHAR","NEW","NONE","NORMALIZE","NOT","NOTNULL","NULL","NULLIF","NULLS","NUMERIC","OFF","OFFLINE","OFFSET","OLD","ON","ONLY","OPEN","OR","ORDER","OUT","OUTER","OVERLAPS","OVERLAY","PARALLEL","PARTITION","PERCENT","PLACING","POSITION","PRECISION","PRIMARY","RAW","READRATIO","REAL","RECOVER","REFERENCES","REJECTLOG","RESORT","RESTORE","RETURNING","RIGHT","ROW","SELECT","SESSION_USER","SETOF","SIMILAR","SMALLINT","SOME","SUBSTRING","SYMMETRIC","SYSDATE","SYSTEM_USER","SYSTEM","TABLE","TABLESAMPLE","TAG","TDES","TEXT255","TEXT32K","THEN","TIME","TIMESTAMP","TO","TOP","TRAILING","TREAT","TRIM","TRUE","TRUNCATECOLUMNS","UNION","UNIQUE","UPDATE","USER","USING","VALUES","VARCHAR","VARIADIC","VERBOSE","WALLET","WHEN","WHERE","WINDOW","WITH","WITHOUT","XMLATTRIBUTES","XMLCONCAT","XMLELEMENT","XMLEXISTS","XMLFOREST","XMLNAMESPACES","XMLPARSE","XMLPI","XMLROOT","XMLSERIALIZE","XMLTABLE"]);function n(e){return e.replace("T"," ").replace("Z","+00")}function i(e,t,n){let i="";for(let[a,r]of(i+=e?" (":"(",t.entries()))i+=(0===a?"":", ")+n(r);return i+")"}function a(e){if(null==e)throw Error("SQL identifier cannot be null or undefined");if(!1===e)return'"f"';if(!0===e)return'"t"';if(e instanceof Date)return`"${n(e.toISOString())}"`;if(Array.isArray(e)){let t=[];for(let n of e)if(!0===Array.isArray(n))throw TypeError("Nested array to grouped list conversion is not supported for SQL identifier");else t.push(a(n));return t.toString()}else if(e===Object(e))throw Error("SQL identifier cannot be an object");let i=String(e).slice(0);if(!0===/^[_a-z][\d$_a-z]*$/.test(i)&&!1==!!t.has(i.toUpperCase()))return i;let r='"';for(let e of i)r+='"'===e?e+e:e;return r+'"'}function r(e){let t,a="";if(null==e)return"NULL";if("bigint"==typeof e)return BigInt(e).toString();if(e===1/0)return"'Infinity'";if(e===-1/0)return"'-Infinity'";if(Number.isNaN(e))return"'NaN'";if("number"==typeof e)return Number(e).toString();if(!1===e)return"'f'";if(!0===e)return"'t'";if(e instanceof Date)return`'${n(e.toISOString())}'`;if(Array.isArray(e)){let t=[];for(let[n,a]of e.entries())!0===Array.isArray(a)?t.push(i(0!==n,a,r)):t.push(r(a));return t.toString()}e===Object(e)?(t="jsonb",a=JSON.stringify(e)):a=String(e).slice(0);let o=!1,l="'";for(let e of a)"'"===e?l+=e+e:"\\"===e?(l+=e+e,o=!0):l+=e;return l+="'",!0===o&&(l=`E${l}`),t&&(l+=`::${t}`),l}function o(e,...t){let l,s;return l=0,s=RegExp("%(%|(\\d+\\$)?[ILs])","g"),e.replace(s,(e,o)=>{if("%"===o)return"%";let s=l,d=o.split("$");if(d.length>1&&(s=Number.parseInt(d[0],10)-1,o=d[1]),s<0)throw Error("specified argument 0 but arguments start at 1");if(s>t.length-1)throw Error("too few arguments");return(l=s+1,"I"===o)?a(t[s]):"L"===o?r(t[s]):"s"===o?function e(t){if(null==t)return"";if(!1===t)return"f";if(!0===t)return"t";if(t instanceof Date)return n(t.toISOString());if(Array.isArray(t)){let n=[];for(let[a,r]of t.entries())null!=r&&(!0===Array.isArray(r)?n.push(i(0!==a,r,e)):n.push(e(r)));return n.toString()}return t===Object(t)?JSON.stringify(t):String(t).toString().slice(0)}(t[s]):void 0})}e.s(["format",()=>o,"ident",()=>a,"literal",()=>r],479084)},755216,e=>{"use strict";var t=e.i(479084);let n=`
-- Can't use pg_authid here since some managed Postgres providers don't expose it
-- https://github.com/supabase/postgres-meta/issues/212

select
  r.oid as id,
  rolname as name,
  rolsuper as "isSuperuser",
  rolcreatedb as "canCreateDb",
  rolcreaterole as "canCreateRole",
  rolinherit as "inheritRole",
  rolcanlogin as "canLogin",
  rolreplication as "isReplicationRole",
  rolbypassrls as "canBypassRls",
  (
    select
      count(*)
    from
      pg_stat_activity
    where
      r.rolname = pg_stat_activity.usename
  ) as "activeConnections",
  case when rolconnlimit = -1 then current_setting('max_connections') :: int8
       else rolconnlimit
  end as "connectionLimit",
  rolvaliduntil as "validUntil",
  coalesce(r_config.role_configs, '{}') as config
from
  pg_roles r
  left join (
    select
      oid,
      jsonb_object_agg(param, value) filter (where param is not null) as role_configs
    from
      (
        select
          oid,
          (string_to_array(unnest(rolconfig), '='))[1] as param,
          (string_to_array(unnest(rolconfig), '='))[2] as value
        from
          pg_roles
      ) as _
    group by
      oid
  ) r_config on r_config.oid = r.oid
`;var i=e.i(97429);let a=i.z.object({id:i.z.number(),name:i.z.string(),isSuperuser:i.z.boolean(),canCreateDb:i.z.boolean(),canCreateRole:i.z.boolean(),inheritRole:i.z.boolean(),canLogin:i.z.boolean(),isReplicationRole:i.z.boolean(),canBypassRls:i.z.boolean(),activeConnections:i.z.number(),connectionLimit:i.z.number(),validUntil:i.z.union([i.z.string(),i.z.null()]),config:i.z.record(i.z.string(),i.z.string())}),r=i.z.array(a),o=i.z.optional(a);function l(e){if("id"in e&&e.id)return`${(0,t.ident)("id")} = ${(0,t.literal)(e.id)}`;if("name"in e&&e.name)return`${(0,t.ident)("name")} = ${(0,t.literal)(e.name)}`;throw Error("Must provide either id or name")}var s=e.i(248593);let d=(e,t)=>`
COALESCE(
  (
    SELECT
      array_agg(row_to_json(${e})) FILTER (WHERE ${t})
    FROM
      ${e}
  ),
  '{}'
) AS ${e}`;function c(e,n,i){return(i&&(n=i.concat(n??[])),e?.length)?`IN (${e.map(t.literal).join(",")})`:n?.length?`NOT IN (${n.map(t.literal).join(",")})`:""}let u=`
-- Adapted from information_schema.columns

SELECT
  c.oid :: int8 AS table_id,
  nc.nspname AS schema,
  c.relname AS table,
  (c.oid || '.' || a.attnum) AS id,
  a.attnum AS ordinal_position,
  a.attname AS name,
  CASE
    WHEN a.atthasdef THEN pg_get_expr(ad.adbin, ad.adrelid)
    ELSE NULL
  END AS default_value,
  CASE
    WHEN t.typtype = 'd' THEN CASE
      WHEN bt.typelem <> 0 :: oid
      AND bt.typlen = -1 THEN 'ARRAY'
      WHEN nbt.nspname = 'pg_catalog' THEN format_type(t.typbasetype, NULL)
      ELSE 'USER-DEFINED'
    END
    ELSE CASE
      WHEN t.typelem <> 0 :: oid
      AND t.typlen = -1 THEN 'ARRAY'
      WHEN nt.nspname = 'pg_catalog' THEN format_type(a.atttypid, NULL)
      ELSE 'USER-DEFINED'
    END
  END AS data_type,
  COALESCE(bt.typname, t.typname) AS format,
  a.attidentity IN ('a', 'd') AS is_identity,
  CASE
    a.attidentity
    WHEN 'a' THEN 'ALWAYS'
    WHEN 'd' THEN 'BY DEFAULT'
    ELSE NULL
  END AS identity_generation,
  a.attgenerated IN ('s') AS is_generated,
  NOT (
    a.attnotnull
    OR t.typtype = 'd' AND t.typnotnull
  ) AS is_nullable,
  (
    c.relkind IN ('r', 'p')
    OR c.relkind IN ('v', 'f') AND pg_column_is_updatable(c.oid, a.attnum, FALSE)
  ) AS is_updatable,
  uniques.table_id IS NOT NULL AS is_unique,
  check_constraints.definition AS "check",
  array_to_json(
    array(
      SELECT
        enumlabel
      FROM
        pg_catalog.pg_enum enums
      WHERE
        enums.enumtypid = coalesce(bt.oid, t.oid)
        OR enums.enumtypid = coalesce(bt.typelem, t.typelem)
      ORDER BY
        enums.enumsortorder
    )
  ) AS enums,
  col_description(c.oid, a.attnum) AS comment
FROM
  pg_attribute a
  LEFT JOIN pg_attrdef ad ON a.attrelid = ad.adrelid
  AND a.attnum = ad.adnum
  JOIN (
    pg_class c
    JOIN pg_namespace nc ON c.relnamespace = nc.oid
  ) ON a.attrelid = c.oid
  JOIN (
    pg_type t
    JOIN pg_namespace nt ON t.typnamespace = nt.oid
  ) ON a.atttypid = t.oid
  LEFT JOIN (
    pg_type bt
    JOIN pg_namespace nbt ON bt.typnamespace = nbt.oid
  ) ON t.typtype = 'd'
  AND t.typbasetype = bt.oid
  LEFT JOIN (
    SELECT DISTINCT ON (table_id, ordinal_position)
      conrelid AS table_id,
      conkey[1] AS ordinal_position
    FROM pg_catalog.pg_constraint
    WHERE contype = 'u' AND cardinality(conkey) = 1
  ) AS uniques ON uniques.table_id = c.oid AND uniques.ordinal_position = a.attnum
  LEFT JOIN (
    -- We only select the first column check
    SELECT DISTINCT ON (table_id, ordinal_position)
      conrelid AS table_id,
      conkey[1] AS ordinal_position,
      substring(
        pg_get_constraintdef(pg_constraint.oid, true),
        8,
        length(pg_get_constraintdef(pg_constraint.oid, true)) - 8
      ) AS "definition"
    FROM pg_constraint
    WHERE contype = 'c' AND cardinality(conkey) = 1
    ORDER BY table_id, ordinal_position, oid asc
  ) AS check_constraints ON check_constraints.table_id = c.oid AND check_constraints.ordinal_position = a.attnum
WHERE
  NOT pg_is_other_temp_schema(nc.oid)
  AND a.attnum > 0
  AND NOT a.attisdropped
  AND (c.relkind IN ('r', 'v', 'm', 'f', 'p'))
  AND (
    pg_has_role(c.relowner, 'USAGE')
    OR has_column_privilege(
      c.oid,
      a.attnum,
      'SELECT, INSERT, UPDATE, REFERENCES'
    )
  )
`,m=i.z.object({id:i.z.string(),table_id:i.z.number(),schema:i.z.string(),table:i.z.string(),name:i.z.string(),ordinal_position:i.z.number(),data_type:i.z.string(),format:i.z.string(),is_identity:i.z.boolean(),identity_generation:i.z.string().nullable(),is_generated:i.z.boolean(),is_nullable:i.z.boolean(),is_updatable:i.z.boolean(),is_unique:i.z.boolean(),check:i.z.string().nullable(),default_value:i.z.any().nullable(),enums:i.z.array(i.z.string()),comment:i.z.string().nullable()}),p=i.z.array(m),_=i.z.optional(m),g=e=>e.endsWith("[]")?`${(0,t.ident)(e.slice(0,-2))}[]`:e.includes(".")?e:(0,t.ident)(e),E=`
-- Adapted from information_schema.schemata

select
  n.oid as id,
  n.nspname as name,
  u.rolname as owner,
   obj_description(n.oid, 'pg_namespace') AS comment
from
  pg_namespace n,
  pg_roles u
where
  n.nspowner = u.oid
  and (
    pg_has_role(n.nspowner, 'USAGE')
    or has_schema_privilege(n.oid, 'CREATE, USAGE')
  )
  and not pg_catalog.starts_with(n.nspname, 'pg_temp_')
  and not pg_catalog.starts_with(n.nspname, 'pg_toast_temp_')
`,f=i.z.object({id:i.z.number(),name:i.z.string(),owner:i.z.string(),comment:i.z.string().nullable()}),b=i.z.array(f),$=i.z.optional(f),h=`
SELECT
  c.oid :: int8 AS id,
  nc.nspname AS schema,
  c.relname AS name,
  c.relrowsecurity AS rls_enabled,
  c.relforcerowsecurity AS rls_forced,
  CASE
    WHEN c.relreplident = 'd' THEN 'DEFAULT'
    WHEN c.relreplident = 'i' THEN 'INDEX'
    WHEN c.relreplident = 'f' THEN 'FULL'
    ELSE 'NOTHING'
  END AS replica_identity,
  pg_total_relation_size(format('%I.%I', nc.nspname, c.relname)) :: int8 AS bytes,
  pg_size_pretty(
    pg_total_relation_size(format('%I.%I', nc.nspname, c.relname))
  ) AS size,
  pg_stat_get_live_tuples(c.oid) AS live_rows_estimate,
  pg_stat_get_dead_tuples(c.oid) AS dead_rows_estimate,
  obj_description(c.oid) AS comment,
  coalesce(pk.primary_keys, '[]') as primary_keys,
  coalesce(
    jsonb_agg(relationships) filter (where relationships is not null),
    '[]'
  ) as relationships
FROM
  pg_namespace nc
  JOIN pg_class c ON nc.oid = c.relnamespace
  left join (
    select
      c.oid::int8 as table_id,
      jsonb_agg(
        jsonb_build_object(
          'table_id', c.oid::int8,
          'schema', n.nspname,
          'table_name', c.relname,
          'name', a.attname
        )
        order by array_position(i.indkey, a.attnum)
      ) as primary_keys
    from
      pg_index i
      join pg_class c on i.indrelid = c.oid
      join pg_namespace n on c.relnamespace = n.oid
      join pg_attribute a on a.attrelid = c.oid and a.attnum = any(i.indkey)
    where
      i.indisprimary
    group by c.oid
  ) as pk
  on pk.table_id = c.oid
  left join (
    select
      c.oid :: int8 as id,
      c.conname as constraint_name,
      nsa.nspname as source_schema,
      csa.relname as source_table_name,
      sa.attname as source_column_name,
      nta.nspname as target_table_schema,
      cta.relname as target_table_name,
      ta.attname as target_column_name
    from
      pg_constraint c
    join (
      pg_attribute sa
      join pg_class csa on sa.attrelid = csa.oid
      join pg_namespace nsa on csa.relnamespace = nsa.oid
    ) on sa.attrelid = c.conrelid and sa.attnum = any (c.conkey)
    join (
      pg_attribute ta
      join pg_class cta on ta.attrelid = cta.oid
      join pg_namespace nta on cta.relnamespace = nta.oid
    ) on ta.attrelid = c.confrelid and ta.attnum = any (c.confkey)
    where
      c.contype = 'f'
  ) as relationships
  on (relationships.source_schema = nc.nspname and relationships.source_table_name = c.relname)
  or (relationships.target_table_schema = nc.nspname and relationships.target_table_name = c.relname)
WHERE
  c.relkind IN ('r', 'p')
  AND NOT pg_is_other_temp_schema(nc.oid)
  AND (
    pg_has_role(c.relowner, 'USAGE')
    OR has_table_privilege(
      c.oid,
      'SELECT, INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER'
    )
    OR has_any_column_privilege(c.oid, 'SELECT, INSERT, UPDATE, REFERENCES')
  )
group by
  c.oid,
  c.relname,
  c.relrowsecurity,
  c.relforcerowsecurity,
  c.relreplident,
  nc.nspname,
  pk.primary_keys
`,A=i.z.object({table_id:i.z.number(),name:i.z.string(),schema:i.z.string(),table_name:i.z.string()}),T=i.z.object({id:i.z.number(),constraint_name:i.z.string(),source_schema:i.z.string(),source_table_name:i.z.string(),source_column_name:i.z.string(),target_table_schema:i.z.string(),target_table_name:i.z.string(),target_column_name:i.z.string()}),S=i.z.object({id:i.z.number(),schema:i.z.string(),name:i.z.string(),rls_enabled:i.z.boolean(),rls_forced:i.z.boolean(),replica_identity:i.z.enum(["DEFAULT","INDEX","FULL","NOTHING"]),bytes:i.z.number(),size:i.z.string(),live_rows_estimate:i.z.number(),dead_rows_estimate:i.z.number(),comment:i.z.string().nullable(),primary_keys:i.z.array(A),relationships:i.z.array(T),columns:p.optional()}),N=i.z.array(S);function y({includeSystemSchemas:e=!1,includedSchemas:t,excludedSchemas:n,limit:i,offset:a,includeColumns:r=!0}={}){let o=R({includeColumns:r}),l=c(t,n,e?void 0:s.DEFAULT_SYSTEM_SCHEMAS);return l&&(o+=` where schema ${l}`),i&&(o+=` limit ${i}`),a&&(o+=` offset ${a}`),{sql:o,zod:N}}function z(e){let n=function(e){if("id"in e&&e.id)return`${(0,t.ident)("id")} = ${(0,t.literal)(e.id)}`;if("name"in e&&e.name&&e.schema)return`${(0,t.ident)("name")} = ${(0,t.literal)(e.name)} and ${(0,t.ident)("schema")} = ${(0,t.literal)(e.schema)}`;throw Error("Must provide either id or name and schema")}(e);return{sql:`${R({includeColumns:!0})} where ${n};`,zod:S}}function L(e,{cascade:n=!1}={}){return{sql:`DROP TABLE ${(0,t.ident)(e.schema)}.${(0,t.ident)(e.name)} ${n?"CASCADE":"RESTRICT"};`}}let R=({includeColumns:e})=>`
  with tables as (${h})
  ${e?`, columns as (${u})`:""}
  select
    *
    ${e?`, ${d("columns","columns.table_id = tables.id")}`:""}
  from tables`;function I({name:e,schema:n="public",comment:i}){let a=`CREATE TABLE ${(0,t.ident)(n)}.${(0,t.ident)(e)} ();`,r=void 0!=i?`COMMENT ON TABLE ${(0,t.ident)(n)}.${(0,t.ident)(e)} IS ${(0,t.literal)(i)};`:"";return{sql:`BEGIN; ${a} ${r} COMMIT;`}}function v(e,{name:n,schema:i,rls_enabled:a,rls_forced:r,replica_identity:o,replica_identity_index:l,primary_keys:s,comment:d}){let c=`ALTER TABLE ${(0,t.ident)(e.schema)}.${(0,t.ident)(e.name)}`,u=void 0===i?"":`${c} SET SCHEMA ${(0,t.ident)(i)};`,m="";if(void 0!==n&&n!==e.name){let a=void 0===i?e.schema:i;m=`ALTER TABLE ${(0,t.ident)(a)}.${(0,t.ident)(e.name)} RENAME TO ${(0,t.ident)(n)};`}let p="";if(void 0!==a){let e=`${c} ENABLE ROW LEVEL SECURITY;`,t=`${c} DISABLE ROW LEVEL SECURITY;`;p=a?e:t}let _="";if(void 0!==r){let e=`${c} FORCE ROW LEVEL SECURITY;`,t=`${c} NO FORCE ROW LEVEL SECURITY;`;_=r?e:t}let g="";void 0===o||(g="INDEX"===o?`${c} REPLICA IDENTITY USING INDEX ${l};`:`${c} REPLICA IDENTITY ${o};`);let E="";void 0===s||(E+=`
DO $$
DECLARE
  r record;
BEGIN
  SELECT conname
    INTO r
    FROM pg_constraint
    WHERE contype = 'p' AND conrelid = ${(0,t.literal)(e.id)};
  IF r IS NOT NULL THEN
    EXECUTE ${(0,t.literal)(`${c} DROP CONSTRAINT `)} || quote_ident(r.conname);
  END IF;
END
$$;
`,0===s.length||(E+=`${c} ADD PRIMARY KEY (${s.map(e=>(0,t.ident)(e.name)).join(",")});`));let f=void 0==d?"":`COMMENT ON TABLE ${(0,t.ident)(e.schema)}.${(0,t.ident)(e.name)} IS ${(0,t.literal)(d)};`;return{sql:`
BEGIN;
  ${p}
  ${_}
  ${g}
  ${E}
  ${f}
  ${u}
  ${m}
COMMIT;`}}e.s(["create",()=>I,"list",()=>y,"remove",()=>L,"retrieve",()=>z,"update",()=>v],330006);var O=e.i(330006);let w=`
-- CTE with sane arg_modes, arg_names, and arg_types.
-- All three are always of the same length.
-- All three include all args, including OUT and TABLE args.
with functions as (
  select
    *,
    -- proargmodes is null when all arg modes are IN
    coalesce(
      p.proargmodes,
      array_fill('i'::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])
    ) as arg_modes,
    -- proargnames is null when all args are unnamed
    coalesce(
      p.proargnames,
      array_fill(''::text, array[cardinality(coalesce(p.proallargtypes, p.proargtypes))])
    ) as arg_names,
    -- proallargtypes is null when all arg modes are IN
    coalesce(p.proallargtypes, p.proargtypes) as arg_types,
    array_cat(
      array_fill(false, array[pronargs - pronargdefaults]),
      array_fill(true, array[pronargdefaults])) as arg_has_defaults
  from
    pg_proc as p
  where
    p.prokind = 'f'
)
select
  f.oid as id,
  n.nspname as schema,
  f.proname as name,
  l.lanname as language,
  case
    when l.lanname = 'internal' then ''
    else f.prosrc
  end as definition,
  case
    when l.lanname = 'internal' then f.prosrc
    else pg_get_functiondef(f.oid)
  end as complete_statement,
  coalesce(f_args.args, '[]') as args,
  pg_get_function_arguments(f.oid) as argument_types,
  pg_get_function_identity_arguments(f.oid) as identity_argument_types,
  f.prorettype as return_type_id,
  pg_get_function_result(f.oid) as return_type,
  nullif(rt.typrelid, 0) as return_type_relation_id,
  f.proretset as is_set_returning_function,
  case
    when f.provolatile = 'i' then 'IMMUTABLE'
    when f.provolatile = 's' then 'STABLE'
    when f.provolatile = 'v' then 'VOLATILE'
  end as behavior,
  f.prosecdef as security_definer,
  f_config.config_params as config_params
from
  functions f
  left join pg_namespace n on f.pronamespace = n.oid
  left join pg_language l on f.prolang = l.oid
  left join pg_type rt on rt.oid = f.prorettype
  left join (
    select
      oid,
      jsonb_object_agg(param, value) filter (where param is not null) as config_params
    from
      (
        select
          oid,
          (string_to_array(unnest(proconfig), '='))[1] as param,
          (string_to_array(unnest(proconfig), '='))[2] as value
        from
          functions
      ) as t
    group by
      oid
  ) f_config on f_config.oid = f.oid
  left join (
    select
      oid,
      jsonb_agg(jsonb_build_object(
        'mode', t2.mode,
        'name', name,
        'type_id', type_id,
        -- Cast null into false boolean
        'has_default', COALESCE(has_default, false)
      )) as args
    from
      (
        select
          oid,
          unnest(arg_modes) as mode,
          unnest(arg_names) as name,
          -- Coming from: coalesce(p.proallargtypes, p.proargtypes) postgres won't automatically assume
          -- integer, we need to cast it to be properly parsed
          unnest(arg_types)::int8 as type_id,
          unnest(arg_has_defaults) as has_default
        from
          functions
      ) as t1,
      lateral (
        select
          case
            when t1.mode = 'i' then 'in'
            when t1.mode = 'o' then 'out'
            when t1.mode = 'b' then 'inout'
            when t1.mode = 'v' then 'variadic'
            else 'table'
          end as mode
      ) as t2
    group by
      t1.oid
  ) f_args on f_args.oid = f.oid
`,C=i.z.object({id:i.z.number(),schema:i.z.string(),name:i.z.string(),language:i.z.string(),definition:i.z.string(),complete_statement:i.z.string(),args:i.z.array(i.z.object({mode:i.z.union([i.z.literal("in"),i.z.literal("out"),i.z.literal("inout"),i.z.literal("variadic"),i.z.literal("table")]),name:i.z.string(),type_id:i.z.number(),has_default:i.z.boolean()})),argument_types:i.z.string(),identity_argument_types:i.z.string(),return_type_id:i.z.number(),return_type:i.z.string(),return_type_relation_id:i.z.union([i.z.number(),i.z.null()]),is_set_returning_function:i.z.boolean(),behavior:i.z.union([i.z.literal("IMMUTABLE"),i.z.literal("STABLE"),i.z.literal("VOLATILE")]),security_definer:i.z.boolean(),config_params:i.z.union([i.z.record(i.z.string(),i.z.string()),i.z.null()])}),D=i.z.array(C),x=i.z.optional(C);function U({includeSystemSchemas:e=!1,includedSchemas:t,excludedSchemas:n,limit:i,offset:a}={}){let r=`
    with f as (
      ${w}
    )
    select
      f.*
    from f
  `,o=c(t,n,e?void 0:s.DEFAULT_SYSTEM_SCHEMAS);return o&&(r+=` where schema ${o}`),i&&(r=`${r} limit ${i}`),a&&(r=`${r} offset ${a}`),{sql:r,zod:D}}function M({id:e,name:n,schema:i="public",args:a=[]}){if(e)return{sql:`
      with f as (
        ${w}
      )
      select
        f.*
      from f where id = ${(0,t.literal)(e)};`,zod:x};if(n&&i&&a)return{sql:`with f as (
      ${w}
    )
    select
      f.*
    from f join pg_proc as p on id = p.oid where schema = ${(0,t.literal)(i)} and name = ${(0,t.literal)(n)} and p.proargtypes::text = ${a.length?`(
          select string_agg(type_oid::text, ' ') from (
            select (
              split_args.arr[
                array_length(
                  split_args.arr,
                  1
                )
              ]::regtype::oid
            ) as type_oid from (
              select string_to_array(
                unnest(
                  array[${a.map(t.literal)}]
                ),
                ' '
              ) as arr
            ) as split_args
          ) args
        )`:(0,t.literal)("")}`,zod:x};throw Error("Must provide either id or name and schema")}let j=i.z.object({name:i.z.string(),definition:i.z.string(),args:i.z.array(i.z.string()).optional(),behavior:i.z.enum(["IMMUTABLE","STABLE","VOLATILE"]).optional(),config_params:i.z.record(i.z.string(),i.z.string()).optional(),schema:i.z.string().optional(),language:i.z.string().optional(),return_type:i.z.string().optional(),security_definer:i.z.boolean().optional()});function F({name:e,schema:n,args:i,definition:a,return_type:r,language:o,behavior:l,security_definer:s,config_params:d},{replace:c=!1}={}){return`
    CREATE ${c?"OR REPLACE":""} FUNCTION ${(0,t.ident)(n)}.${(0,t.ident)(e)}(${i?.join(", ")||""})
    RETURNS ${r}
    AS ${(0,t.literal)(a)}
    LANGUAGE ${o}
    ${l}
    CALLED ON NULL INPUT
    ${s?"SECURITY DEFINER":"SECURITY INVOKER"}
    ${d?Object.entries(d).map(([e,t])=>`SET ${e} ${"FROM CURRENT"===t?"FROM CURRENT":"TO "+('""'===t?"''":t)}`).join("\n"):""};
  `}function k({name:e,schema:t="public",args:n=[],definition:a,return_type:r="void",language:o="sql",behavior:l="VOLATILE",security_definer:s=!1,config_params:d={}}){return{sql:F({name:e,schema:t,args:n,definition:a,return_type:r,language:o,behavior:l,security_definer:s,config_params:d}),zod:i.z.void()}}let Z=i.z.object({name:i.z.string().optional(),schema:i.z.string().optional(),definition:i.z.string().optional()});function P(e,{name:n,schema:a,definition:r}){let o=e.argument_types.split(", "),l=e.identity_argument_types,s="string"==typeof r?F({...e,definition:r,args:o,config_params:e.config_params??{}},{replace:!0}):"",d=n&&n!==e.name?`ALTER FUNCTION ${(0,t.ident)(e.schema)}.${(0,t.ident)(e.name)}(${l}) RENAME TO ${(0,t.ident)(n)};`:"",c=a&&a!==e.schema?`ALTER FUNCTION ${(0,t.ident)(e.schema)}.${(0,t.ident)(n||e.name)}(${l})  SET SCHEMA ${(0,t.ident)(a)};`:"";return{sql:`
    DO LANGUAGE plpgsql $$
    BEGIN
      IF ${"string"==typeof r?"TRUE":"FALSE"} THEN
        ${s}

        IF (
          SELECT id
          FROM (${w}) AS f
          WHERE f.schema = ${(0,t.literal)(e.schema)}
          AND f.name = ${(0,t.literal)(e.name)}
          AND f.identity_argument_types = ${(0,t.literal)(l)}
        ) != ${e.id} THEN
          RAISE EXCEPTION 'Cannot find function "${e.schema}"."${e.name}"(${l})';
        END IF;
      END IF;

      ${d}

      ${c}
    END;
    $$;
  `,zod:i.z.void()}}let H=i.z.object({cascade:i.z.boolean().default(!1).optional()});function B(e,{cascade:n=!1}={}){return{sql:`DROP FUNCTION ${(0,t.ident)(e.schema)}.${(0,t.ident)(e.name)}
  (${e.identity_argument_types})
  ${n?"CASCADE":"RESTRICT"};`,zod:i.z.void()}}e.s(["create",()=>k,"list",()=>U,"pgFunctionArrayZod",0,D,"pgFunctionCreateZod",0,j,"pgFunctionDeleteZod",0,H,"pgFunctionOptionalZod",0,x,"pgFunctionUpdateZod",0,Z,"pgFunctionZod",0,C,"remove",()=>B,"retrieve",()=>M,"update",()=>P],198687);var Y=e.i(198687);let q=`
-- Despite the name \`table_privileges\`, this includes other kinds of relations:
-- views, matviews, etc. "Relation privileges" just doesn't roll off the tongue.
--
-- For each relation, get its relacl in a jsonb format,
-- e.g.
--
-- '{postgres=arwdDxt/postgres}'
--
-- becomes
--
-- [
--   {
--     "grantee": "postgres",
--     "grantor": "postgres",
--     "is_grantable": false,
--     "privilege_type": "INSERT"
--   },
--   ...
-- ]
select
  c.oid as relation_id,
  nc.nspname as schema,
  c.relname as name,
  case
    when c.relkind = 'r' then 'table'
    when c.relkind = 'v' then 'view'
    when c.relkind = 'm' then 'materialized_view'
    when c.relkind = 'f' then 'foreign_table'
    when c.relkind = 'p' then 'partitioned_table'
  end as kind,
  coalesce(
    jsonb_agg(
      jsonb_build_object(
        'grantor', grantor.rolname,
        'grantee', grantee.rolname,
        'privilege_type', _priv.privilege_type,
        'is_grantable', _priv.is_grantable
      )
    ) filter (where _priv is not null),
    '[]'
  ) as privileges
from pg_class c
join pg_namespace as nc
  on nc.oid = c.relnamespace
left join lateral (
  select grantor, grantee, privilege_type, is_grantable
  from aclexplode(coalesce(c.relacl, acldefault('r', c.relowner)))
) as _priv on true
left join pg_roles as grantor
  on grantor.oid = _priv.grantor
left join (
  select
    pg_roles.oid,
    pg_roles.rolname
  from pg_roles
  union all
  select
    (0)::oid as oid, 'PUBLIC'
) as grantee (oid, rolname)
  on grantee.oid = _priv.grantee
where c.relkind in ('r', 'v', 'm', 'f', 'p')
  and not pg_is_other_temp_schema(c.relnamespace)
  and (
    pg_has_role(c.relowner, 'USAGE')
    or has_table_privilege(
      c.oid,
      'SELECT, INSERT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER'
      || case when current_setting('server_version_num')::int4 >= 170000 then ', MAINTAIN' else '' end
    )
    or has_any_column_privilege(c.oid, 'SELECT, INSERT, UPDATE, REFERENCES')
  )
group by
  c.oid,
  nc.nspname,
  c.relname,
  c.relkind
`,G=i.z.object({relation_id:i.z.number(),schema:i.z.string(),name:i.z.string(),kind:i.z.union([i.z.literal("table"),i.z.literal("view"),i.z.literal("materialized_view"),i.z.literal("foreign_table"),i.z.literal("partitioned_table")]),privileges:i.z.array(i.z.object({grantor:i.z.string(),grantee:i.z.string(),privilege_type:i.z.union([i.z.literal("SELECT"),i.z.literal("INSERT"),i.z.literal("UPDATE"),i.z.literal("DELETE"),i.z.literal("TRUNCATE"),i.z.literal("REFERENCES"),i.z.literal("TRIGGER"),i.z.literal("MAINTAIN")]),is_grantable:i.z.boolean()}))}),W=i.z.array(G),J=i.z.optional(G),V=`
SELECT
  p.oid :: int8 AS id,
  p.pubname AS name,
  p.pubowner::regrole::text AS owner,
  p.pubinsert AS publish_insert,
  p.pubupdate AS publish_update,
  p.pubdelete AS publish_delete,
  p.pubtruncate AS publish_truncate,
  CASE
    WHEN p.puballtables THEN NULL
    ELSE pr.tables
  END AS tables
FROM
  pg_catalog.pg_publication AS p
  LEFT JOIN LATERAL (
    SELECT
      COALESCE(
        array_agg(
          json_build_object(
            'id',
            c.oid :: int8,
            'name',
            c.relname,
            'schema',
            nc.nspname
          )
        ),
        '{}'
      ) AS tables
    FROM
      pg_catalog.pg_publication_rel AS pr
      JOIN pg_class AS c ON pr.prrelid = c.oid
      join pg_namespace as nc on c.relnamespace = nc.oid
    WHERE
      pr.prpubid = p.oid
  ) AS pr ON 1 = 1
`,Q=i.z.object({id:i.z.number().optional(),name:i.z.string(),schema:i.z.string()}),X=i.z.object({id:i.z.number(),name:i.z.string(),owner:i.z.string(),publish_insert:i.z.boolean(),publish_update:i.z.boolean(),publish_delete:i.z.boolean(),publish_truncate:i.z.boolean(),tables:i.z.array(Q).nullable()}),K=i.z.array(X),ee=i.z.optional(X),et=`
SELECT
  e.name,
  n.nspname AS schema,
  e.default_version,
  x.extversion AS installed_version,
  e.comment
FROM
  pg_available_extensions() e(name, default_version, comment)
  LEFT JOIN pg_extension x ON e.name = x.extname
  LEFT JOIN pg_namespace n ON x.extnamespace = n.oid
`,en=i.z.object({name:i.z.string(),schema:i.z.string().nullable(),default_version:i.z.string(),installed_version:i.z.string().nullable(),comment:i.z.string()}),ei=i.z.array(en),ea=i.z.optional(en),er=`
SELECT
  name,
  setting,
  category,
  TRIM(split_part(category, '/', 1)) AS group,
  TRIM(split_part(category, '/', 2)) AS subgroup,
  unit,
  short_desc,
  extra_desc,
  context,
  vartype,
  source,
  min_val,
  max_val,
  enumvals,
  boot_val,
  reset_val,
  sourcefile,
  sourceline,
  pending_restart
FROM
  pg_settings
ORDER BY
  category,
  name
`,eo=i.z.object({name:i.z.string(),setting:i.z.string(),category:i.z.string(),group:i.z.string(),subgroup:i.z.string(),unit:i.z.string().nullable(),short_desc:i.z.string(),extra_desc:i.z.string().nullable(),context:i.z.string(),vartype:i.z.string(),source:i.z.string(),min_val:i.z.string().nullable(),max_val:i.z.string().nullable(),enumvals:i.z.array(i.z.string()).nullable(),boot_val:i.z.string().nullable(),reset_val:i.z.string().nullable(),sourcefile:i.z.string().nullable(),sourceline:i.z.number().nullable(),pending_restart:i.z.boolean()}),el=i.z.array(eo),es=`
select
  c.oid::int8 as id,
  n.nspname as schema,
  c.relname as name,
  c.relispopulated as is_populated,
  obj_description(c.oid) as comment
from
  pg_class c
  join pg_namespace n on n.oid = c.relnamespace
where
  c.relkind = 'm'
`,ed=i.z.object({id:i.z.number(),schema:i.z.string(),name:i.z.string(),is_populated:i.z.boolean(),comment:i.z.string().nullable(),columns:p.optional()}),ec=i.z.array(ed),eu=i.z.optional(ed),em=({includeColumns:e})=>`
with materialized_views as (${es})
  ${e?`, columns as (${u})`:""}
select
  *
  ${e?`, ${d("columns","columns.table_id = materialized_views.id")}`:""}
from materialized_views`,ep=`
select
  c.oid::int8 as id,
  n.nspname as schema,
  c.relname as name,
  obj_description(c.oid) as comment,
  fs.srvname as foreign_server_name,
  fdw.fdwname as foreign_data_wrapper_name,
  handler.proname as foreign_data_wrapper_handler
from
  pg_class c
  join pg_namespace n on n.oid = c.relnamespace
  inner join pg_foreign_table ft on ft.ftrelid = c.oid
  inner join pg_foreign_server fs on fs.oid = ft.ftserver
  inner join pg_foreign_data_wrapper fdw on fdw.oid = fs.srvfdw
  inner join pg_proc handler on handler.oid = fdw.fdwhandler
where
  c.relkind = 'f'
`,e_=i.z.object({id:i.z.number(),schema:i.z.string(),name:i.z.string(),comment:i.z.string().nullable(),foreign_server_name:i.z.string(),foreign_data_wrapper_name:i.z.string(),foreign_data_wrapper_handler:i.z.string(),columns:p.optional()}),eg=i.z.array(e_),eE=i.z.optional(e_),ef=({includeColumns:e})=>`
with foreign_tables as (${ep})
  ${e?`, columns as (${u})`:""}
select
  *
  ${e?`, ${d("columns","columns.table_id = foreign_tables.id")}`:""}
from foreign_tables`,eb=`
SELECT
  c.oid :: int8 AS id,
  n.nspname AS schema,
  c.relname AS name,
  (pg_relation_is_updatable(c.oid, false) & 20) = 20 AS is_updatable,
  obj_description(c.oid) AS comment
FROM
  pg_class c
  JOIN pg_namespace n ON n.oid = c.relnamespace
WHERE
  c.relkind = 'v'
`,e$=i.z.object({id:i.z.number(),schema:i.z.string(),name:i.z.string(),is_updatable:i.z.boolean(),comment:i.z.string().nullable(),columns:p.optional()}),eh=i.z.array(e$),eA=i.z.optional(e$),eT=({includeColumns:e})=>`
with views as (${eb})
  ${e?`, columns as (${u})`:""}
select
  *
  ${e?`, ${d("columns","columns.table_id = views.id")}`:""}
from views`,eS=`
select
  pol.oid :: int8 as id,
  n.nspname as schema,
  c.relname as table,
  c.oid :: int8 as table_id,
  pol.polname as name,
  case
    when pol.polpermissive then 'PERMISSIVE'::text
    else 'RESTRICTIVE'::text
  end as action,
  case
    when pol.polroles = '{0}'::oid[] then array_to_json(string_to_array('public'::text, ''::text)::name[])
    else array_to_json(array(
      select pg_roles.rolname
      from pg_roles
      where pg_roles.oid = any(pol.polroles)
      order by pg_roles.rolname
    ))
  end as roles,
  case pol.polcmd
    when 'r'::"char" then 'SELECT'::text
    when 'a'::"char" then 'INSERT'::text
    when 'w'::"char" then 'UPDATE'::text
    when 'd'::"char" then 'DELETE'::text
    when '*'::"char" then 'ALL'::text
    else null::text
  end as command,
  pg_get_expr(pol.polqual, pol.polrelid) as definition,
  pg_get_expr(pol.polwithcheck, pol.polrelid) as check
from
  pg_policy pol
  join pg_class c on c.oid = pol.polrelid
  left join pg_namespace n on n.oid = c.relnamespace
`,eN=i.z.object({id:i.z.number(),schema:i.z.string(),table:i.z.string(),table_id:i.z.number(),name:i.z.string(),action:i.z.union([i.z.literal("PERMISSIVE"),i.z.literal("RESTRICTIVE")]),roles:i.z.array(i.z.string()),command:i.z.union([i.z.literal("SELECT"),i.z.literal("INSERT"),i.z.literal("UPDATE"),i.z.literal("DELETE"),i.z.literal("ALL")]),definition:i.z.union([i.z.string(),i.z.null()]),check:i.z.union([i.z.string(),i.z.null()])}),ey=i.z.array(eN),ez=i.z.optional(eN),eL=`
SELECT
  pg_t.oid AS id,
  pg_t.tgrelid AS table_id,
  CASE
    WHEN pg_t.tgenabled = 'D' THEN 'DISABLED'
    WHEN pg_t.tgenabled = 'O' THEN 'ORIGIN'
    WHEN pg_t.tgenabled = 'R' THEN 'REPLICA'
    WHEN pg_t.tgenabled = 'A' THEN 'ALWAYS'
  END AS enabled_mode,
  (
    STRING_TO_ARRAY(
      ENCODE(pg_t.tgargs, 'escape'), '\\000'
    )
  )[:pg_t.tgnargs] AS function_args,
  is_t.trigger_name AS name,
  is_t.event_object_table AS table,
  is_t.event_object_schema AS schema,
  is_t.action_condition AS condition,
  is_t.action_orientation AS orientation,
  is_t.action_timing AS activation,
  ARRAY_AGG(is_t.event_manipulation)::text[] AS events,
  pg_p.proname AS function_name,
  pg_n.nspname AS function_schema
FROM
  pg_trigger AS pg_t
JOIN
  pg_class AS pg_c
ON pg_t.tgrelid = pg_c.oid
JOIN information_schema.triggers AS is_t
ON is_t.trigger_name = pg_t.tgname
AND pg_c.relname = is_t.event_object_table
AND pg_c.relnamespace = (quote_ident(is_t.event_object_schema))::regnamespace
JOIN pg_proc AS pg_p
ON pg_t.tgfoid = pg_p.oid
JOIN pg_namespace AS pg_n
ON pg_p.pronamespace = pg_n.oid
GROUP BY
  pg_t.oid,
  pg_t.tgrelid,
  pg_t.tgenabled,
  pg_t.tgargs,
  pg_t.tgnargs,
  is_t.trigger_name,
  is_t.event_object_table,
  is_t.event_object_schema,
  is_t.action_condition,
  is_t.action_orientation,
  is_t.action_timing,
  pg_p.proname,
  pg_n.nspname
`,eR=i.z.object({id:i.z.number(),table_id:i.z.number(),enabled_mode:i.z.enum(["DISABLED","ORIGIN","REPLICA","ALWAYS"]),function_args:i.z.array(i.z.string()),name:i.z.string(),table:i.z.string(),schema:i.z.string(),condition:i.z.string().nullable(),orientation:i.z.string(),activation:i.z.string(),events:i.z.array(i.z.string()),function_name:i.z.string(),function_schema:i.z.string()}),eI=i.z.array(eR),ev=i.z.optional(eR);i.z.object({name:i.z.string(),schema:i.z.string().optional().default("public"),table:i.z.string(),function_schema:i.z.string().optional().default("public"),function_name:i.z.string(),function_args:i.z.array(i.z.string()).optional(),activation:i.z.enum(["BEFORE","AFTER","INSTEAD OF"]),events:i.z.array(i.z.string()),orientation:i.z.enum(["ROW","STATEMENT"]).optional(),condition:i.z.string().optional()}),i.z.object({name:i.z.string().optional(),enabled_mode:i.z.enum(["ORIGIN","REPLICA","ALWAYS","DISABLED"]).optional()});let eO=`
select
  t.oid::int8 as id,
  t.typname as name,
  n.nspname as schema,
  format_type (t.oid, null) as format,
  coalesce(t_enums.enums, '[]') as enums,
  coalesce(t_attributes.attributes, '[]') as attributes,
  obj_description (t.oid, 'pg_type') as comment
from
  pg_type t
  left join pg_namespace n on n.oid = t.typnamespace
  left join (
    select
      enumtypid,
      jsonb_agg(enumlabel order by enumsortorder) as enums
    from
      pg_enum
    group by
      enumtypid
  ) as t_enums on t_enums.enumtypid = t.oid
  left join (
    select
      oid,
      jsonb_agg(
        jsonb_build_object('name', a.attname, 'type_id', a.atttypid::int8)
        order by a.attnum asc
      ) as attributes
    from
      pg_class c
      join pg_attribute a on a.attrelid = c.oid
    where
      c.relkind = 'c' and not a.attisdropped
    group by
      c.oid
  ) as t_attributes on t_attributes.oid = t.typrelid
where
  (
    t.typrelid = 0
    or (
      select
        c.relkind = 'c'
      from
        pg_class c
      where
        c.oid = t.typrelid
    )
  )
`,ew=i.z.object({id:i.z.number(),name:i.z.string(),schema:i.z.string(),format:i.z.string(),enums:i.z.array(i.z.string()),attributes:i.z.array(i.z.object({name:i.z.string(),type_id:i.z.number()})),comment:i.z.string().nullable()}),eC=i.z.array(ew),eD=`
select
  version(),
  current_setting('server_version_num')::int8 as version_number,
  (
    select
      count(*) as active_connections
    from
      pg_stat_activity
  ) as active_connections,
  current_setting('max_connections')::int8 as max_connections
`,ex=i.z.object({version:i.z.string(),version_number:i.z.number(),active_connections:i.z.number(),max_connections:i.z.number()}),eU=`
  SELECT
    idx.indexrelid::int8 AS id,
    idx.indrelid::int8 AS table_id,
    n.nspname AS schema,
    idx.indnatts AS number_of_attributes,
    idx.indnkeyatts AS number_of_key_attributes,
    idx.indisunique AS is_unique,
    idx.indisprimary AS is_primary,
    idx.indisexclusion AS is_exclusion,
    idx.indimmediate AS is_immediate,
    idx.indisclustered AS is_clustered,
    idx.indisvalid AS is_valid,
    idx.indcheckxmin AS check_xmin,
    idx.indisready AS is_ready,
    idx.indislive AS is_live,
    idx.indisreplident AS is_replica_identity,
    idx.indkey::smallint[] AS key_attributes,
    idx.indcollation::integer[] AS collation,
    idx.indclass::integer[] AS class,
    idx.indoption::smallint[] AS options,
    idx.indpred AS index_predicate,
    obj_description(idx.indexrelid, 'pg_class') AS comment,
    ix.indexdef as index_definition,
    am.amname AS access_method,
    jsonb_agg(
      jsonb_build_object(
        'attribute_number', a.attnum,
        'attribute_name', a.attname,
        'data_type', format_type(a.atttypid, a.atttypmod)
      )
      ORDER BY a.attnum
    ) AS index_attributes
  FROM
    pg_index idx
    JOIN pg_class c ON c.oid = idx.indexrelid
    JOIN pg_namespace n ON c.relnamespace = n.oid
    JOIN pg_am am ON c.relam = am.oid
    JOIN pg_attribute a ON a.attrelid = c.oid AND a.attnum = ANY(idx.indkey)
    JOIN pg_indexes ix ON c.relname = ix.indexname
  GROUP BY
    idx.indexrelid, idx.indrelid, n.nspname, idx.indnatts, idx.indnkeyatts, idx.indisunique, 
    idx.indisprimary, idx.indisexclusion, idx.indimmediate, idx.indisclustered, idx.indisvalid, 
    idx.indcheckxmin, idx.indisready, idx.indislive, idx.indisreplident, idx.indkey, 
    idx.indcollation, idx.indclass, idx.indoption, idx.indexprs, idx.indpred, ix.indexdef, am.amname
`,eM=i.z.object({id:i.z.number(),table_id:i.z.number(),schema:i.z.string(),number_of_attributes:i.z.number(),number_of_key_attributes:i.z.number(),is_unique:i.z.boolean(),is_primary:i.z.boolean(),is_exclusion:i.z.boolean(),is_immediate:i.z.boolean(),is_clustered:i.z.boolean(),is_valid:i.z.boolean(),check_xmin:i.z.boolean(),is_ready:i.z.boolean(),is_live:i.z.boolean(),is_replica_identity:i.z.boolean(),key_attributes:i.z.array(i.z.number()),collation:i.z.array(i.z.number()),class:i.z.array(i.z.number()),options:i.z.array(i.z.number()),index_predicate:i.z.string().nullable(),comment:i.z.string().nullable(),index_definition:i.z.string(),access_method:i.z.string(),index_attributes:i.z.array(i.z.object({attribute_number:i.z.number(),attribute_name:i.z.string(),data_type:i.z.string()}))}),ej=i.z.array(eM),eF=i.z.optional(eM),ek=`
-- Lists each column's privileges in the form of:
--
-- [
--   {
--     "column_id": "12345.1",
--     "relation_schema": "public",
--     "relation_name": "mytable",
--     "column_name": "mycolumn",
--     "privileges": [
--       {
--         "grantor": "postgres",
--         "grantee": "myrole",
--         "privilege_type": "SELECT",
--         "is_grantable": false
--       },
--       ...
--     ]
--   },
--   ...
-- ]
--
-- Modified from information_schema.column_privileges. We try to be as close as
-- possible to the view definition, obtained from:
--
-- select pg_get_viewdef('information_schema.column_privileges');
--
-- The main differences are:
-- - we include column privileges for materialized views
--   (reason for exclusion in information_schema.column_privileges:
--    https://www.postgresql.org/message-id/9136.1502740844%40sss.pgh.pa.us)
-- - we query a.attrelid and a.attnum to generate column_id
-- - table_catalog is omitted
-- - table_schema -> relation_schema, table_name -> relation_name
--
-- Column privileges are intertwined with table privileges in that table
-- privileges override column privileges. E.g. if we do:
--
-- grant all on mytable to myrole;
--
-- Then myrole is granted privileges for ALL columns. Likewise, if we do:
--
-- grant all (id) on mytable to myrole;
-- revoke all on mytable from myrole;
--
-- Then the grant on the id column is revoked.
--
-- This is unlike how grants for schemas and tables interact, where you need
-- privileges for BOTH the schema the table is in AND the table itself in order
-- to access the table.

select (x.attrelid || '.' || x.attnum) as column_id,
       nc.nspname as relation_schema,
       x.relname as relation_name,
       x.attname as column_name,
       coalesce(
         jsonb_agg(
           jsonb_build_object(
             'grantor', u_grantor.rolname,
             'grantee', grantee.rolname,
             'privilege_type', x.prtype,
             'is_grantable', x.grantable
           )
         ),
         '[]'
       ) as privileges
from
  (select pr_c.grantor,
          pr_c.grantee,
          a.attrelid,
          a.attnum,
          a.attname,
          pr_c.relname,
          pr_c.relnamespace,
          pr_c.prtype,
          pr_c.grantable,
          pr_c.relowner
   from
     (select pg_class.oid,
             pg_class.relname,
             pg_class.relnamespace,
             pg_class.relowner,
             (aclexplode(coalesce(pg_class.relacl, acldefault('r', pg_class.relowner)))).grantor as grantor,
             (aclexplode(coalesce(pg_class.relacl, acldefault('r', pg_class.relowner)))).grantee as grantee,
             (aclexplode(coalesce(pg_class.relacl, acldefault('r', pg_class.relowner)))).privilege_type as privilege_type,
             (aclexplode(coalesce(pg_class.relacl, acldefault('r', pg_class.relowner)))).is_grantable as is_grantable
      from pg_class
      where (pg_class.relkind = any (array['r',
                                           'v',
                                           'm',
                                           'f',
                                           'p'])) ) pr_c(oid, relname, relnamespace, relowner, grantor, grantee, prtype, grantable),
                                                    pg_attribute a
   where ((a.attrelid = pr_c.oid)
          and (a.attnum > 0)
          and (not a.attisdropped))
   union select pr_a.grantor,
                pr_a.grantee,
                pr_a.attrelid,
                pr_a.attnum,
                pr_a.attname,
                c.relname,
                c.relnamespace,
                pr_a.prtype,
                pr_a.grantable,
                c.relowner
   from
     (select a.attrelid,
             a.attnum,
             a.attname,
             (aclexplode(coalesce(a.attacl, acldefault('c', cc.relowner)))).grantor as grantor,
             (aclexplode(coalesce(a.attacl, acldefault('c', cc.relowner)))).grantee as grantee,
             (aclexplode(coalesce(a.attacl, acldefault('c', cc.relowner)))).privilege_type as privilege_type,
             (aclexplode(coalesce(a.attacl, acldefault('c', cc.relowner)))).is_grantable as is_grantable
      from (pg_attribute a
            join pg_class cc on ((a.attrelid = cc.oid)))
      where ((a.attnum > 0)
             and (not a.attisdropped))) pr_a(attrelid, attnum, attname, grantor, grantee, prtype, grantable),
                                        pg_class c
   where ((pr_a.attrelid = c.oid)
          and (c.relkind = any (ARRAY['r',
                                      'v',
                                      'm',
                                      'f',
                                      'p'])))) x,
     pg_namespace nc,
     pg_authid u_grantor,
  (select pg_authid.oid,
          pg_authid.rolname
   from pg_authid
   union all select (0)::oid as oid,
                    'PUBLIC') grantee(oid, rolname)
where ((x.relnamespace = nc.oid)
       and (x.grantee = grantee.oid)
       and (x.grantor = u_grantor.oid)
       and (x.prtype = any (ARRAY['INSERT',
                                  'SELECT',
                                  'UPDATE',
                                  'REFERENCES']))
       and (pg_has_role(u_grantor.oid, 'USAGE')
            or pg_has_role(grantee.oid, 'USAGE')
            or (grantee.rolname = 'PUBLIC')))
group by column_id,
         nc.nspname,
         x.relname,
         x.attname
`,eZ=i.z.object({grantor:i.z.string(),grantee:i.z.string(),privilege_type:i.z.union([i.z.literal("SELECT"),i.z.literal("INSERT"),i.z.literal("UPDATE"),i.z.literal("REFERENCES")]),is_grantable:i.z.boolean()}),eP=i.z.object({column_id:i.z.string(),relation_schema:i.z.string(),relation_name:i.z.string(),column_name:i.z.string(),privileges:i.z.array(eZ)}),eH=i.z.array(eP);i.z.object({columnId:i.z.string(),grantee:i.z.string(),privilegeType:i.z.union([i.z.literal("ALL"),i.z.literal("SELECT"),i.z.literal("INSERT"),i.z.literal("UPDATE"),i.z.literal("REFERENCES")]),isGrantable:i.z.boolean().optional()}),e.i(967533);var eB=e.i(977540),eY=e.i(332357),eq=e.i(193767),eG=e.i(212695),eW=e.i(29659);e.s(["Query",()=>eB.Query,"QueryAction",()=>eG.QueryAction,"QueryFilter",()=>eq.QueryFilter,"QueryModifier",()=>eW.QueryModifier,"countQuery",()=>eY.countQuery,"deleteQuery",()=>eY.deleteQuery,"insertQuery",()=>eY.insertQuery,"selectQuery",()=>eY.selectQuery,"truncateQuery",()=>eY.truncateQuery,"updateQuery",()=>eY.updateQuery],377171);var eJ=e.i(377171);let eV=["idx_users_email","idx_users_created_at_desc","idx_users_last_sign_in_at_desc","idx_users_name","users_phone_key"];e.s(["default",0,{roles:{list:function({includeDefaultRoles:e=!1,limit:t,offset:i}={}){let a=`
with
  roles as (${n})
select
  *
from
  roles
where
  true
`;return e||(a+=" and not pg_catalog.starts_with(name, 'pg_')"),t&&(a+=` limit ${t}`),i&&(a+=` offset ${i}`),{sql:a,zod:r}},retrieve:function(e){return{sql:`with roles as (${n}) select * from roles where ${l(e)};`,zod:o}},create:function({name:e,isSuperuser:n=!1,canCreateDb:i=!1,canCreateRole:a=!1,inheritRole:r=!0,canLogin:o=!1,isReplicationRole:l=!1,canBypassRls:s=!1,connectionLimit:d=-1,password:c,validUntil:u,memberOf:m=[],members:p=[],admins:_=[],config:g={}}){return{sql:`
create role ${(0,t.ident)(e)}
  ${n?"superuser":""}
  ${i?"createdb":""}
  ${a?"createrole":""}
  ${r?"":"noinherit"}
  ${o?"login":""}
  ${l?"replication":""}
  ${s?"bypassrls":""}
  connection limit ${d}
  ${void 0===c?"":`password ${(0,t.literal)(c)}`}
  ${void 0===u?"":`valid until ${(0,t.literal)(u)}`}
  ${0===m.length?"":`in role ${m.map(t.ident).join(",")}`}
  ${0===p.length?"":`role ${p.map(t.ident).join(",")}`}
  ${0===_.length?"":`admin ${_.map(t.ident).join(",")}`}
  ;
${Object.entries(g).map(([n,i])=>`alter role ${(0,t.ident)(e)} set ${(0,t.ident)(n)} = ${(0,t.literal)(i)};`).join("\n")}
`}},update:function(e,i){let{name:a,isSuperuser:r,canCreateDb:o,canCreateRole:s,inheritRole:d,canLogin:c,isReplicationRole:u,canBypassRls:m,connectionLimit:p,password:_,validUntil:g}=i;return{sql:`
do $$
declare
  old record;
begin
  with roles as (${n})
  select * into old from roles where ${l(e)};
  if old is null then
    raise exception 'Cannot find role with id %', id;
  end if;

  execute(format('alter role %I
    ${void 0===r?"":r?"superuser":"nosuperuser"}
    ${void 0===o?"":o?"createdb":"nocreatedb"}
    ${void 0===s?"":s?"createrole":"nocreaterole"}
    ${void 0===d?"":d?"inherit":"noinherit"}
    ${void 0===c?"":c?"login":"nologin"}
    ${void 0===u?"":u?"replication":"noreplication"}
    ${void 0===m?"":m?"bypassrls":"nobypassrls"}
    ${void 0===p?"":`connection limit ${p}`}
    ${void 0===_?"":`password ${(0,t.literal)(_)}`}
    ${void 0===g?"":"valid until %L"}
  ', old.name${void 0===g?"":`, ${(0,t.literal)(g)}`}));

  ${void 0===a?"":`
  -- Using the same name in the rename clause gives an error, so only do it if the new name is different.
  if ${(0,t.literal)(a)} != old.name then
    execute(format('alter role %I rename to %I;', old.name, ${(0,t.literal)(a)}));
  end if;
  `}
end
$$;
`}},remove:function(e,{ifExists:t=!1}={}){return{sql:`
do $$
declare
  old record;
begin
  with roles as (${n})
  select * into old from roles where ${l(e)};
  if old is null then
    raise exception 'Cannot find role with id %', id;
  end if;

  execute(format('drop role ${t?"if exists":""} %I;', old.name));
end
$$;
`}},zod:a},columns:{list:function({tableId:e,includeSystemSchemas:n=!1,includedSchemas:i,excludedSchemas:a,limit:r,offset:o}={}){let l=`
with
  columns as (${u})
select
  *
from
  columns
where
 true
`,d=c(i,a,n?void 0:s.DEFAULT_SYSTEM_SCHEMAS);return d&&(l+=` and schema ${d}`),void 0!==e&&(l+=` and table_id = ${(0,t.literal)(e)} `),r&&(l=`${l} limit ${r}`),o&&(l=`${l} offset ${o}`),{sql:l,zod:p}},retrieve:function(e){return{sql:`WITH columns AS (${u}) SELECT * FROM columns WHERE ${function(e){if("id"in e&&e.id)return`${(0,t.ident)("id")} = ${(0,t.literal)(e.id)}`;if("name"in e&&e.name&&e.schema&&e.table)return`schema = ${(0,t.literal)(e.schema)} AND ${(0,t.ident)("table")} = ${(0,t.literal)(e.table)} AND name = ${(0,t.literal)(e.name)}`;throw Error("Must provide either id or schema, name and table")}(e)};`,zod:_}},create:function({schema:e,table:n,name:i,type:a,default_value:r,default_value_format:o="literal",is_identity:l=!1,identity_generation:s="BY DEFAULT",is_nullable:d,is_primary_key:c=!1,is_unique:u=!1,comment:m,check:p}){let _="";if(l){if(void 0!==r)throw Error("Columns cannot both be identity and have a default value");_=`GENERATED ${s} AS IDENTITY`}else void 0===r||(_="expression"===o?`DEFAULT ${r}`:`DEFAULT ${(0,t.literal)(r)}`);let E="";void 0!==d&&(E=d?"NULL":"NOT NULL");let f=void 0===p?"":`CHECK (${p})`,b=void 0===m?"":`COMMENT ON COLUMN ${(0,t.ident)(e)}.${(0,t.ident)(n)}.${(0,t.ident)(i)} IS ${(0,t.literal)(m)}`;return{sql:`
BEGIN;
  ALTER TABLE ${(0,t.ident)(e)}.${(0,t.ident)(n)} ADD COLUMN ${(0,t.ident)(i)} ${g(a)}
    ${_}
    ${E}
    ${c?"PRIMARY KEY":""}
    ${u?"UNIQUE":""}
    ${f};
  ${b};
COMMIT;`}},update:function(e,{name:n,type:i,drop_default:a=!1,default_value:r,default_value_format:o="literal",is_identity:l,identity_generation:s="BY DEFAULT",is_nullable:d,is_unique:c,comment:u,check:m}){let p,_,E=void 0===n||n===e.name?"":`ALTER TABLE ${(0,t.ident)(e.schema)}.${(0,t.ident)(e.table)} RENAME COLUMN ${(0,t.ident)(e.name)} TO ${(0,t.ident)(n)};`,f=void 0===i?"":`ALTER TABLE ${(0,t.ident)(e.schema)}.${(0,t.ident)(e.table)} ALTER COLUMN ${(0,t.ident)(e.name)} SET DATA TYPE ${g(i)} USING ${(0,t.ident)(e.name)}::${g(i)};`;if(a)p=`ALTER TABLE ${(0,t.ident)(e.schema)}.${(0,t.ident)(e.table)} ALTER COLUMN ${(0,t.ident)(e.name)} DROP DEFAULT;`;else if(void 0===r)p="";else{let n="expression"===o?r:(0,t.literal)(r);p=`ALTER TABLE ${(0,t.ident)(e.schema)}.${(0,t.ident)(e.table)} ALTER COLUMN ${(0,t.ident)(e.name)} SET DEFAULT ${n};`}let b=`ALTER TABLE ${(0,t.ident)(e.schema)}.${(0,t.ident)(e.table)} ALTER COLUMN ${(0,t.ident)(e.name)}`;!1===l?b+=" DROP IDENTITY IF EXISTS;":!0===e.is_identity?void 0===s?b="":b+=` SET GENERATED ${s};`:void 0===l?b="":b+=` ADD GENERATED ${s} AS IDENTITY;`,_=void 0===d?"":d?`ALTER TABLE ${(0,t.ident)(e.schema)}.${(0,t.ident)(e.table)} ALTER COLUMN ${(0,t.ident)(e.name)} DROP NOT NULL;`:`ALTER TABLE ${(0,t.ident)(e.schema)}.${(0,t.ident)(e.table)} ALTER COLUMN ${(0,t.ident)(e.name)} SET NOT NULL;`;let $="";!0===e.is_unique&&!1===c?$=`
DO $$
DECLARE
  r record;
BEGIN
  FOR r IN
    SELECT conname FROM pg_constraint WHERE
      contype = 'u'
      AND cardinality(conkey) = 1
      AND conrelid = ${(0,t.literal)(e.table_id)}
      AND conkey[1] = ${(0,t.literal)(e.ordinal_position)}
  LOOP
    EXECUTE ${(0,t.literal)(`ALTER TABLE ${(0,t.ident)(e.schema)}.${(0,t.ident)(e.table)} DROP CONSTRAINT `)} || quote_ident(r.conname);
  END LOOP;
END
$$;
`:!1===e.is_unique&&!0===c&&($=`ALTER TABLE ${(0,t.ident)(e.schema)}.${(0,t.ident)(e.table)} ADD UNIQUE (${(0,t.ident)(e.name)});`);let h=void 0===u?"":`COMMENT ON COLUMN ${(0,t.ident)(e.schema)}.${(0,t.ident)(e.table)}.${(0,t.ident)(e.name)} IS ${(0,t.literal)(u)};`,A=void 0===m?"":`
DO $$
DECLARE
  v_conname name;
  v_conkey int2[];
BEGIN
  SELECT conname into v_conname FROM pg_constraint WHERE
    contype = 'c'
    AND cardinality(conkey) = 1
    AND conrelid = ${(0,t.literal)(e.table_id)}
    AND conkey[1] = ${(0,t.literal)(e.ordinal_position)}
    ORDER BY oid asc
    LIMIT 1;

  IF v_conname IS NOT NULL THEN
    EXECUTE format('ALTER TABLE ${(0,t.ident)(e.schema)}.${(0,t.ident)(e.table)} DROP CONSTRAINT %I', v_conname);
  END IF;

  ${null!==m?`
  ALTER TABLE ${(0,t.ident)(e.schema)}.${(0,t.ident)(e.table)} ADD CONSTRAINT ${(0,t.ident)(`${e.table}_${e.name}_check`)} CHECK (${m});

  SELECT conkey into v_conkey FROM pg_constraint WHERE conname = ${(0,t.literal)(`${e.table}_${e.name}_check`)};

  ASSERT v_conkey IS NOT NULL, 'error creating column constraint: check condition must refer to this column';
  ASSERT cardinality(v_conkey) = 1, 'error creating column constraint: check condition cannot refer to multiple columns';
  ASSERT v_conkey[1] = ${(0,t.literal)(e.ordinal_position)}, 'error creating column constraint: check condition cannot refer to other columns';
`:""}
END
$$;
`;return{sql:`
BEGIN;
  ${_}
  ${f}
  ${p}
  ${b}
  ${$}
  ${h}
  ${A}
  ${E}
COMMIT;`}},remove:function(e,{cascade:n=!1}={}){return{sql:`ALTER TABLE ${(0,t.ident)(e.schema)}.${(0,t.ident)(e.table)} DROP COLUMN ${(0,t.ident)(e.name)} ${n?"CASCADE":"RESTRICT"};`}},zod:m},schemas:{list:function({includeSystemSchemas:e=!1,limit:n,offset:i}={}){let a=E;return e||(a=`${a} and not (n.nspname in (${s.DEFAULT_SYSTEM_SCHEMAS.map(t.literal).join(",")}))`),n&&(a=`${a} limit ${n}`),i&&(a=`${a} offset ${i}`),{sql:a,zod:b}},retrieve:function({id:e,name:n}){return e?{sql:`${E} and n.oid = ${(0,t.literal)(e)};`,zod:$}:{sql:`${E} and n.nspname = ${(0,t.literal)(n)};`,zod:$}},create:function({name:e,owner:n}){return{sql:`create schema ${(0,t.ident)(e)}
  ${void 0===n?"":`authorization ${(0,t.ident)(n)}`};
`}},update:function({id:e,name:n},{name:i,owner:a}){return{sql:`
do $$
declare
  id oid := ${void 0===e?`${(0,t.literal)(n)}::regnamespace`:(0,t.literal)(e)};
  old record;
  new_name text := ${void 0===i?null:(0,t.literal)(i)};
  new_owner text := ${void 0===a?null:(0,t.literal)(a)};
begin
  select * into old from pg_namespace where oid = id;
  if old is null then
    raise exception 'Cannot find schema with id %', id;
  end if;

  if new_owner is not null then
    execute(format('alter schema %I owner to %I;', old.nspname, new_owner));
  end if;

  -- Using the same name in the rename clause gives an error, so only do it if the new name is different.
  if new_name is not null and new_name != old.nspname then
    execute(format('alter schema %I rename to %I;', old.nspname, new_name));
  end if;
end
$$;
`}},remove:function({id:e,name:n},{cascade:i=!1}={}){return{sql:`
do $$
declare
  id oid := ${void 0===e?`${(0,t.literal)(n)}::regnamespace`:(0,t.literal)(e)};
  old record;
  cascade bool := ${(0,t.literal)(i)};
begin
  select * into old from pg_namespace where oid = id;
  if old is null then
    raise exception 'Cannot find schema with id %', id;
  end if;

  execute(format('drop schema %I %s;', old.nspname, case when cascade then 'cascade' else 'restrict' end));
end
$$;
`}},zod:f},tables:O,functions:Y,tablePrivileges:{list:function({includeSystemSchemas:e=!1,includedSchemas:t,excludedSchemas:n,limit:i,offset:a}={}){let r=`
with table_privileges as (${q})
select *
from table_privileges
`,o=c(t,n,e?void 0:s.DEFAULT_SYSTEM_SCHEMAS);return o&&(r+=` where schema ${o}`),i&&(r+=` limit ${i}`),a&&(r+=` offset ${a}`),{sql:r,zod:W}},retrieve:function({id:e,name:n,schema:i="public"}){return e?{sql:`
with table_privileges as (${q})
select *
from table_privileges
where table_privileges.relation_id = ${(0,t.literal)(e)};`,zod:J}:{sql:`
with table_privileges as (${q})
select *
from table_privileges
where table_privileges.schema = ${(0,t.literal)(i)}
  and table_privileges.name = ${(0,t.literal)(n)}
`,zod:J}},grant:function(e){return{sql:`
do $$
begin
${e.map(({privilegeType:e,relationId:n,grantee:i,isGrantable:a})=>`execute format('grant ${e} on table %s to ${"public"===i.toLowerCase()?"public":(0,t.ident)(i)} ${a?"with grant option":""}', ${n}::regclass);`).join("\n")}
end $$;
`}},revoke:function(e){return{sql:`
do $$
begin
${e.map(({privilegeType:e,relationId:n,grantee:i})=>`execute format('revoke ${e} on table %s from ${"public"===i.toLowerCase()?"public":(0,t.ident)(i)}', ${n}::regclass);`).join("\n")}
end $$;
`}},zod:G},publications:{list:function({limit:e,offset:t}={}){let n=`with publications as (${V}) select * from publications`;return e&&(n+=` limit ${e}`),t&&(n+=` offset ${t}`),{sql:n,zod:K}},retrieve:function(e){return{sql:`with publications as (${V}) select * from publications where ${function(e){if("id"in e&&e.id)return`${(0,t.ident)("id")} = ${(0,t.literal)(e.id)}`;if("name"in e&&e.name)return`${(0,t.ident)("name")} = ${(0,t.literal)(e.name)}`;throw Error("Must provide either id or name")}(e)};`,zod:ee}},create:function({name:e,publish_insert:n=!1,publish_update:i=!1,publish_delete:a=!1,publish_truncate:r=!1,tables:o=null}){let l;l=null==o?"FOR ALL TABLES":0===o.length?"":`FOR TABLE ${o.map(e=>{if(!e.includes("."))return(0,t.ident)(e);let[n,...i]=e.split("."),a=i.join(".");return`${(0,t.ident)(n)}.${(0,t.ident)(a)}`}).join(",")}`;let s=[];return n&&s.push("insert"),i&&s.push("update"),a&&s.push("delete"),r&&s.push("truncate"),{sql:`
CREATE PUBLICATION ${(0,t.ident)(e)} ${l}
  WITH (publish = '${s.join(",")}');`}},update:function(e,{name:n,owner:i,publish_insert:a,publish_update:r,publish_delete:o,publish_truncate:l,tables:s}){return{sql:`
do $$
declare
  id oid := ${(0,t.literal)(e)};
  old record;
  new_name text := ${void 0===n?null:(0,t.literal)(n)};
  new_owner text := ${void 0===i?null:(0,t.literal)(i)};
  new_publish_insert bool := ${a??null};
  new_publish_update bool := ${r??null};
  new_publish_delete bool := ${o??null};
  new_publish_truncate bool := ${l??null};
  new_tables text := ${void 0===s?null:(0,t.literal)(null===s?"all tables":s.map(e=>{if(!e.includes("."))return(0,t.ident)(e);let[n,...i]=e.split("."),a=i.join(".");return`${(0,t.ident)(n)}.${(0,t.ident)(a)}`}).join(","))};
begin
  select * into old from pg_publication where oid = id;
  if old is null then
    raise exception 'Cannot find publication with id %', id;
  end if;

  if new_tables is null then
    null;
  elsif new_tables = 'all tables' then
    if old.puballtables then
      null;
    else
      -- Need to recreate because going from list of tables <-> all tables with alter is not possible.
      execute(format('drop publication %1$I; create publication %1$I for all tables;', old.pubname));
    end if;
  else
    if old.puballtables then
      -- Need to recreate because going from list of tables <-> all tables with alter is not possible.
      execute(format('drop publication %1$I; create publication %1$I;', old.pubname));
    elsif exists(select from pg_publication_rel where prpubid = id) then
      execute(
        format(
          'alter publication %I drop table %s',
          old.pubname,
          (select string_agg(prrelid::regclass::text, ', ') from pg_publication_rel where prpubid = id)
        )
      );
    end if;

    -- At this point the publication must have no tables.

    if new_tables != '' then
      execute(format('alter publication %I add table %s', old.pubname, new_tables));
    end if;
  end if;

  execute(
    format(
      'alter publication %I set (publish = %L);',
      old.pubname,
      concat_ws(
        ', ',
        case when coalesce(new_publish_insert, old.pubinsert) then 'insert' end,
        case when coalesce(new_publish_update, old.pubupdate) then 'update' end,
        case when coalesce(new_publish_delete, old.pubdelete) then 'delete' end,
        case when coalesce(new_publish_truncate, old.pubtruncate) then 'truncate' end
      )
    )
  );

  execute(format('alter publication %I owner to %I;', old.pubname, coalesce(new_owner, old.pubowner::regrole::name)));

  -- Using the same name in the rename clause gives an error, so only do it if the new name is different.
  if new_name is not null and new_name != old.pubname then
    execute(format('alter publication %I rename to %I;', old.pubname, coalesce(new_name, old.pubname)));
  end if;

  -- We need to retrieve the publication later, so we need a way to uniquely identify which publication this is.
  -- We can't rely on id because it gets changed if it got recreated.
  -- We use a temp table to store the unique name - DO blocks can't return a value.
  create temp table pg_meta_publication_tmp (name) on commit drop as values (coalesce(new_name, old.pubname));
end $$;
`}},remove:function(e){return{sql:`DROP PUBLICATION IF EXISTS ${(0,t.ident)(e.name)};`}},zod:X},extensions:{list:function({limit:e,offset:t}={}){let n=et;return e&&(n=`${n} LIMIT ${e}`),t&&(n=`${n} OFFSET ${t}`),{sql:n,zod:ei}},retrieve:function({name:e}){return{sql:`${et} WHERE name = ${(0,t.literal)(e)};`,zod:ea}},create:function({name:e,schema:n,version:i,cascade:a=!1}){return{sql:`
CREATE EXTENSION ${(0,t.ident)(e)}
  ${void 0===n?"":`SCHEMA ${(0,t.ident)(n)}`}
  ${void 0===i?"":`VERSION ${(0,t.literal)(i)}`}
  ${a?"CASCADE":""};`}},update:function(e,{update:n=!1,version:i,schema:a}){let r="";n&&(r=`ALTER EXTENSION ${(0,t.ident)(e)} UPDATE ${void 0===i?"":`TO ${(0,t.literal)(i)}`};`);let o=void 0===a?"":`ALTER EXTENSION ${(0,t.ident)(e)} SET SCHEMA ${(0,t.ident)(a)};`;return{sql:`BEGIN; ${r} ${o} COMMIT;`}},remove:function(e,{cascade:n=!1}={}){return{sql:`DROP EXTENSION ${(0,t.ident)(e)} ${n?"CASCADE":"RESTRICT"};`}},zod:en},config:{list:function({limit:e,offset:t}={}){let n=er;return e&&(n+=` LIMIT ${e}`),t&&(n+=` OFFSET ${t}`),{sql:n,zod:el}},zod:eo},materializedViews:{list:function({includeSystemSchemas:e=!1,includedSchemas:t,excludedSchemas:n,limit:i,offset:a,includeColumns:r=!0}={}){let o=em({includeColumns:r}),l=c(t,n,e?void 0:s.DEFAULT_SYSTEM_SCHEMAS);return l&&(o+=` where schema ${l}`),i&&(o+=` limit ${i}`),a&&(o+=` offset ${a}`),{sql:o,zod:ec}},retrieve:function(e){let n=function(e){if("id"in e&&e.id)return`${(0,t.ident)("id")} = ${(0,t.literal)(e.id)}`;if("name"in e&&e.name&&e.schema)return`${(0,t.ident)("name")} = ${(0,t.literal)(e.name)} and ${(0,t.ident)("schema")} = ${(0,t.literal)(e.schema)}`;throw Error("Must provide either id or name and schema")}(e);return{sql:`${em({includeColumns:!0})} where ${n};`,zod:eu}},zod:ed},foreignTables:{list:function({includeSystemSchemas:e=!1,includedSchemas:t,excludedSchemas:n,limit:i,offset:a,includeColumns:r=!0}={}){let o=ef({includeColumns:r}),l=c(t,n,e?void 0:s.DEFAULT_SYSTEM_SCHEMAS);return l&&(o+=` where schema ${l}`),i&&(o+=` limit ${i}`),a&&(o+=` offset ${a}`),{sql:o,zod:eg}},retrieve:function(e){return{sql:`${ef({includeColumns:!0})} where ${function(e){if("id"in e&&e.id)return`${(0,t.ident)("id")} = ${(0,t.literal)(e.id)}`;if("name"in e&&e.name&&e.schema)return`${(0,t.ident)("name")} = ${(0,t.literal)(e.name)} and ${(0,t.ident)("schema")} = ${(0,t.literal)(e.schema)}`;throw Error("Must provide either id or name and schema")}(e)};`,zod:eE}},zod:e_},views:{list:function({includeSystemSchemas:e=!1,includedSchemas:t,excludedSchemas:n,limit:i,offset:a,includeColumns:r=!0}={}){let o=eT({includeColumns:r}),l=c(t,n,e?void 0:s.DEFAULT_SYSTEM_SCHEMAS);return l&&(o+=` where schema ${l}`),i&&(o+=` limit ${i}`),a&&(o+=` offset ${a}`),{sql:o,zod:eh}},retrieve:function(e){let n=function(e){if("id"in e&&e.id)return`${(0,t.ident)("id")} = ${(0,t.literal)(e.id)}`;if("name"in e&&e.name&&e.schema)return`${(0,t.ident)("name")} = ${(0,t.literal)(e.name)} and ${(0,t.ident)("schema")} = ${(0,t.literal)(e.schema)}`;throw Error("Must provide either id or name and schema")}(e);return{sql:`${eT({includeColumns:!0})} where ${n};`,zod:eA}},zod:e$},policies:{list:function({includeSystemSchemas:e=!1,includedSchemas:t,excludedSchemas:n,limit:i,offset:a}={}){let r=`
    with policies as (${eS})
    select *
    from policies
    `,o=c(t,n,e?void 0:s.DEFAULT_SYSTEM_SCHEMAS);return o&&(r+=`where schema ${o}`),i&&(r+=` limit ${i}`),a&&(r+=` offset ${a}`),{sql:r,zod:ey}},retrieve:function(e){return{sql:`with policies as (${eS}) select * from policies where ${function(e){if("id"in e&&e.id)return`id = ${(0,t.literal)(e.id)}`;if("name"in e&&e.name&&e.schema&&e.table)return`name = ${(0,t.literal)(e.name)} AND schema = ${(0,t.literal)(e.schema)} AND table = ${(0,t.literal)(e.table)}`;throw Error("Must provide either id or name, schema and table")}(e)};`,zod:ez}},create:function({name:e,schema:n="public",table:i,definition:a,check:r,action:o="PERMISSIVE",command:l="ALL",roles:s=["public"]}){return{sql:`
create policy ${(0,t.ident)(e)} on ${(0,t.ident)(n)}.${(0,t.ident)(i)}
  as ${o}
  for ${l}
  to ${s.map(t.ident).join(",")}
  ${a?`using (${a})`:""}
  ${r?`with check (${r})`:""};`}},update:function(e,n){let{name:i,definition:a,check:r,roles:o}=n,l=`ALTER POLICY ${(0,t.ident)(e.name)} ON ${(0,t.ident)(e.schema)}.${(0,t.ident)(e.table)}`,s=void 0===i?"":`${l} RENAME TO ${(0,t.ident)(i)};`,d=void 0===a?"":`${l} USING (${a});`,c=void 0===r?"":`${l} WITH CHECK (${r});`,u=void 0===o?"":`${l} TO ${o.map(t.ident).join(",")};`;return{sql:`BEGIN; ${d} ${c} ${u} ${s} COMMIT;`}},remove:function(e){return{sql:`DROP POLICY ${(0,t.ident)(e.name)} ON ${(0,t.ident)(e.schema)}.${(0,t.ident)(e.table)};`}},zod:eN},triggers:{list:function({includeSystemSchemas:e=!1,includedSchemas:t,excludedSchemas:n,limit:i,offset:a}={}){let r=`with triggers as (${eL}) select * from triggers`,o=c(t,n,e?void 0:s.DEFAULT_SYSTEM_SCHEMAS);return o&&(r+=` where schema ${o}`),i&&(r+=` limit ${i}`),a&&(r+=` offset ${a}`),{sql:r,zod:eI}},retrieve:function(e){let n=function(e){if("id"in e&&e.id)return`${(0,t.ident)("id")} = ${(0,t.literal)(e.id)}`;if("name"in e&&e.name&&e.table&&e.schema)return`${(0,t.ident)("name")} = ${(0,t.literal)(e.name)} and ${(0,t.ident)("schema")} = ${(0,t.literal)(e.schema)} and ${(0,t.ident)("table")} = ${(0,t.literal)(e.table)}`;throw Error("Must provide either id or name, schema and table")}(e);return{sql:`with triggers as (${eL}) select * from triggers where ${n};`,zod:ev}},create:function({name:e,schema:n="public",table:a,function_schema:r="public",function_name:o,function_args:l=[],activation:s,events:d,orientation:c,condition:u}){let m=`${(0,t.ident)(n)}.${(0,t.ident)(a)}`,p=`${(0,t.ident)(r)}.${(0,t.ident)(o)}`,_=d.join(" or "),g=c?`for each ${c}`:"",E=u?`when (${u})`:"",f=l.map(t.literal).join(",");return{sql:`create trigger ${(0,t.ident)(e)} ${s} ${_} on ${m} ${g} ${E} execute function ${p}(${f});`,zod:i.z.void()}},update:function(e,n){let a=`${(0,t.ident)(e.schema)}.${(0,t.ident)(e.table)}`,r="";switch(n.enabled_mode){case"ORIGIN":r=`alter table ${a} enable trigger ${(0,t.ident)(e.name)};`;break;case"DISABLED":r=`alter table ${a} disable trigger ${(0,t.ident)(e.name)};`;break;case"REPLICA":case"ALWAYS":r=`alter table ${a} enable ${n.enabled_mode} trigger ${(0,t.ident)(e.name)};`}let o=n.name&&n.name!==e.name?`alter trigger ${(0,t.ident)(e.name)} on ${a} rename to ${(0,t.ident)(n.name)};`:"";return{sql:`begin; ${r}; ${o}; commit;`,zod:i.z.void()}},remove:function(e,{cascade:n=!1}={}){let a=`${(0,t.ident)(e.schema)}.${(0,t.ident)(e.table)}`;return{sql:`drop trigger ${(0,t.ident)(e.name)} on ${a} ${n?"cascade":""};`,zod:i.z.void()}},zod:eR},types:{list:function({includeArrayTypes:e=!1,includeSystemSchemas:t=!1,includedSchemas:n,excludedSchemas:i,limit:a,offset:r}={}){let o=eO;e||(o+=` and not exists (
      select from pg_type el
      where el.oid = t.typelem
        and el.typarray = t.oid
    )`);let l=c(n,i,t?void 0:s.DEFAULT_SYSTEM_SCHEMAS);return l&&(o+=` and n.nspname ${l}`),a&&(o+=` limit ${a}`),r&&(o+=` offset ${r}`),{sql:o,zod:eC}},zod:ew},version:{retrieve:function(){return{sql:eD,zod:ex}},zod:ex},indexes:{list:function({includeSystemSchemas:e=!1,includedSchemas:t,excludedSchemas:n,limit:i,offset:a}={}){let r=`
    with indexes as (${eU})
    select *
    from indexes
  `,o=c(t,n,e?void 0:s.DEFAULT_SYSTEM_SCHEMAS);return o&&(r+=` where schema ${o}`),i&&(r+=` limit ${i}`),a&&(r+=` offset ${a}`),{sql:r,zod:ej}},retrieve:function({id:e}){return{sql:`
    with indexes as (${eU})
    select *
    from indexes
    where id = ${(0,t.literal)(e)};
  `,zod:eF}},zod:eM},columnPrivileges:{list:function({includeSystemSchemas:e=!1,includedSchemas:n,excludedSchemas:i,columnIds:a,limit:r,offset:o}={}){let l=`
  with column_privileges as (${ek})
  select *
  from column_privileges
  `,d=[],u=c(n,i,e?void 0:s.DEFAULT_SYSTEM_SCHEMAS);return u&&d.push(`relation_schema ${u}`),a?.length&&d.push(`column_id in (${a.map(t.literal).join(",")})`),d.length>0&&(l+=` where ${d.join(" and ")}`),r&&(l+=` limit ${r}`),o&&(l+=` offset ${o}`),{sql:l,zod:eH}},grant:function(e){return{sql:`
do $$
declare
  col record;
begin
${e.map(({privilegeType:e,columnId:n,grantee:i,isGrantable:a})=>{let[r,o]=n.split(".");return`
select *
from pg_attribute a
where a.attrelid = ${(0,t.literal)(r)}
  and a.attnum = ${(0,t.literal)(o)}
into col;
execute format(
  'grant ${e} (%I) on %s to ${"public"===i.toLowerCase()?"public":(0,t.ident)(i)} ${a?"with grant option":""}',
  col.attname,
  col.attrelid::regclass
);`}).join("\n")}
end $$;
`}},revoke:function(e){return{sql:`
do $$
declare
  col record;
begin
${e.map(({privilegeType:e,columnId:n,grantee:i})=>{let[a,r]=n.split(".");return`
select *
from pg_attribute a
where a.attrelid = ${(0,t.literal)(a)}
  and a.attnum = ${(0,t.literal)(r)}
into col;
execute format(
  'revoke ${e} (%I) on %s from ${"public"===i.toLowerCase()?"public":(0,t.ident)(i)}',
  col.attname,
  col.attrelid::regclass
);`}).join("\n")}
end $$;
`}},zod:eP},query:eJ,getIndexWorkerStatusSQL:()=>`SELECT EXISTS (
    SELECT 1 FROM pg_locks
    WHERE locktype = 'advisory'
    AND (classid::bigint << 32 | objid::bigint) = hashtext('auth_index_worker')::bigint
  ) as is_in_progress;`,getIndexStatusesSQL:()=>`SELECT c.relname as index_name, i.indisvalid as is_valid, i.indisready as is_ready
    FROM pg_index i
    JOIN pg_class c ON c.oid = i.indexrelid
    JOIN pg_namespace n ON n.oid = c.relnamespace
    WHERE n.nspname = 'auth'
    AND c.relname IN (${eV.map(t.literal).join(", ")});`,USER_SEARCH_INDEXES:eV}],755216)}]);

//# debugId=e698002f-534e-6ddd-7d1b-646261a0053a
//# sourceMappingURL=864547612cdf2c81.js.map